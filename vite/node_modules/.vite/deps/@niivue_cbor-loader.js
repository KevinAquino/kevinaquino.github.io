import "./chunk-DE7N57LJ.js";
import {
  __publicField
} from "./chunk-DWA4UIM3.js";

// node_modules/cbor-x/decode.js
var decoder;
try {
  decoder = new TextDecoder();
} catch (error) {
}
var src;
var srcEnd;
var position = 0;
var EMPTY_ARRAY = [];
var LEGACY_RECORD_INLINE_ID = 105;
var RECORD_DEFINITIONS_ID = 57342;
var RECORD_INLINE_ID = 57343;
var BUNDLED_STRINGS_ID = 57337;
var PACKED_REFERENCE_TAG_ID = 6;
var STOP_CODE = {};
var maxArraySize = 11281e4;
var maxMapSize = 1681e4;
var strings = EMPTY_ARRAY;
var stringPosition = 0;
var currentDecoder = {};
var currentStructures;
var srcString;
var srcStringStart = 0;
var srcStringEnd = 0;
var bundledStrings;
var referenceMap;
var currentExtensions = [];
var currentExtensionRanges = [];
var packedValues;
var dataView;
var restoreMapsAsObject;
var defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
var sequentialMode = false;
var inlineObjectReadThreshold = 2;
try {
  new Function("");
} catch (error) {
  inlineObjectReadThreshold = Infinity;
}
var Decoder = class _Decoder {
  constructor(options) {
    if (options) {
      if ((options.keyMap || options._keyMap) && !options.useRecords) {
        options.useRecords = false;
        options.mapsAsObjects = true;
      }
      if (options.useRecords === false && options.mapsAsObjects === void 0)
        options.mapsAsObjects = true;
      if (options.getStructures)
        options.getShared = options.getStructures;
      if (options.getShared && !options.structures)
        (options.structures = []).uninitialized = true;
      if (options.keyMap) {
        this.mapKey = /* @__PURE__ */ new Map();
        for (let [k, v] of Object.entries(options.keyMap)) this.mapKey.set(v, k);
      }
    }
    Object.assign(this, options);
  }
  /*
  decodeKey(key) {
  	return this.keyMap
  		? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
  		: key
  }
  */
  decodeKey(key) {
    return this.keyMap ? this.mapKey.get(key) || key : key;
  }
  encodeKey(key) {
    return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;
  }
  encodeKeys(rec) {
    if (!this._keyMap) return rec;
    let map = /* @__PURE__ */ new Map();
    for (let [k, v] of Object.entries(rec)) map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
    return map;
  }
  decodeKeys(map) {
    if (!this._keyMap || map.constructor.name != "Map") return map;
    if (!this._mapKey) {
      this._mapKey = /* @__PURE__ */ new Map();
      for (let [k, v] of Object.entries(this._keyMap)) this._mapKey.set(v, k);
    }
    let res = {};
    map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);
    return res;
  }
  mapDecode(source, end) {
    let res = this.decode(source);
    if (this._keyMap) {
      switch (res.constructor.name) {
        case "Array":
          return res.map((r) => this.decodeKeys(r));
      }
    }
    return res;
  }
  decode(source, end) {
    if (src) {
      return saveState(() => {
        clearSource();
        return this ? this.decode(source, end) : _Decoder.prototype.decode.call(defaultOptions, source, end);
      });
    }
    srcEnd = end > -1 ? end : source.length;
    position = 0;
    stringPosition = 0;
    srcStringEnd = 0;
    srcString = null;
    strings = EMPTY_ARRAY;
    bundledStrings = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      src = null;
      if (source instanceof Uint8Array)
        throw error;
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof _Decoder) {
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead();
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0)
        currentStructures = [];
      packedValues = null;
    }
    return checkedRead();
  }
  decodeMultiple(source, forEach) {
    let values, lastPosition = 0;
    try {
      let size = source.length;
      sequentialMode = true;
      let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
      if (forEach) {
        if (forEach(value) === false) {
          return;
        }
        while (position < size) {
          lastPosition = position;
          if (forEach(checkedRead()) === false) {
            return;
          }
        }
      } else {
        values = [value];
        while (position < size) {
          lastPosition = position;
          values.push(checkedRead());
        }
        return values;
      }
    } catch (error) {
      error.lastPosition = lastPosition;
      error.values = values;
      throw error;
    } finally {
      sequentialMode = false;
      clearSource();
    }
  }
};
function checkedRead() {
  try {
    let result = read();
    if (bundledStrings) {
      if (position >= bundledStrings.postBundlePosition) {
        let error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position == srcEnd) {
      currentStructures = null;
      src = null;
      if (referenceMap)
        referenceMap = null;
    } else if (position > srcEnd) {
      let error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read() {
  let token = src[position++];
  let majorType = token >> 5;
  token = token & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        if (majorType == 7) {
          return getFloat16();
        }
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        if (majorType == 7) {
          let value = dataView.getFloat32(position);
          if (currentDecoder.useFloat32 > 2) {
            let multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];
            position += 4;
            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position += 4;
          return value;
        }
        token = dataView.getUint32(position);
        position += 4;
        break;
      case 27:
        if (majorType == 7) {
          let value = dataView.getFloat64(position);
          position += 8;
          return value;
        }
        if (majorType > 1) {
          if (dataView.getUint32(position) > 0)
            throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          token = dataView.getUint32(position + 4);
        } else if (currentDecoder.int64AsNumber) {
          token = dataView.getUint32(position) * 4294967296;
          token += dataView.getUint32(position + 4);
        } else
          token = dataView.getBigUint64(position);
        position += 8;
        break;
      case 31:
        switch (majorType) {
          case 2:
          // byte string
          case 3:
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4:
            let array = [];
            let value, i = 0;
            while ((value = read()) != STOP_CODE) {
              if (i >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`);
              array[i++] = value;
            }
            return majorType == 4 ? array : majorType == 3 ? array.join("") : Buffer.concat(array);
          case 5:
            let key;
            if (currentDecoder.mapsAsObjects) {
              let object = {};
              let i2 = 0;
              if (currentDecoder.keyMap) {
                while ((key = read()) != STOP_CODE) {
                  if (i2++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`);
                  object[safeKey(currentDecoder.decodeKey(key))] = read();
                }
              } else {
                while ((key = read()) != STOP_CODE) {
                  if (i2++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`);
                  object[safeKey(key)] = read();
                }
              }
              return object;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = /* @__PURE__ */ new Map();
              if (currentDecoder.keyMap) {
                let i2 = 0;
                while ((key = read()) != STOP_CODE) {
                  if (i2++ >= maxMapSize) {
                    throw new Error(`Map size exceeds ${maxMapSize}`);
                  }
                  map.set(currentDecoder.decodeKey(key), read());
                }
              } else {
                let i2 = 0;
                while ((key = read()) != STOP_CODE) {
                  if (i2++ >= maxMapSize) {
                    throw new Error(`Map size exceeds ${maxMapSize}`);
                  }
                  map.set(key, read());
                }
              }
              return map;
            }
          case 7:
            return STOP_CODE;
          default:
            throw new Error("Invalid major type for indefinite length " + majorType);
        }
      default:
        throw new Error("Unknown token " + token);
    }
  }
  switch (majorType) {
    case 0:
      return token;
    case 1:
      return ~token;
    case 2:
      return readBin(token);
    case 3:
      if (srcStringEnd >= position) {
        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string != null)
          return string;
      }
      return readFixedString(token);
    case 4:
      if (token >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`);
      let array = new Array(token);
      for (let i = 0; i < token; i++) array[i] = read();
      return array;
    case 5:
      if (token >= maxMapSize) throw new Error(`Map size exceeds ${maxArraySize}`);
      if (currentDecoder.mapsAsObjects) {
        let object = {};
        if (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read();
        else for (let i = 0; i < token; i++) object[safeKey(read())] = read();
        return object;
      } else {
        if (restoreMapsAsObject) {
          currentDecoder.mapsAsObjects = true;
          restoreMapsAsObject = false;
        }
        let map = /* @__PURE__ */ new Map();
        if (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()), read());
        else for (let i = 0; i < token; i++) map.set(read(), read());
        return map;
      }
    case 6:
      if (token >= BUNDLED_STRINGS_ID) {
        let structure = currentStructures[token & 8191];
        if (structure) {
          if (!structure.read) structure.read = createStructureReader(structure);
          return structure.read();
        }
        if (token < 65536) {
          if (token == RECORD_INLINE_ID) {
            let length = readJustLength();
            let id = read();
            let structure2 = read();
            recordDefinition(id, structure2);
            let object = {};
            if (currentDecoder.keyMap) for (let i = 2; i < length; i++) {
              let key = currentDecoder.decodeKey(structure2[i - 2]);
              object[safeKey(key)] = read();
            }
            else for (let i = 2; i < length; i++) {
              let key = structure2[i - 2];
              object[safeKey(key)] = read();
            }
            return object;
          } else if (token == RECORD_DEFINITIONS_ID) {
            let length = readJustLength();
            let id = read();
            for (let i = 2; i < length; i++) {
              recordDefinition(id++, read());
            }
            return read();
          } else if (token == BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            structure = currentStructures[token & 8191];
            if (structure) {
              if (!structure.read)
                structure.read = createStructureReader(structure);
              return structure.read();
            }
          }
        }
      }
      let extension = currentExtensions[token];
      if (extension) {
        if (extension.handlesRead)
          return extension(read);
        else
          return extension(read());
      } else {
        let input = read();
        for (let i = 0; i < currentExtensionRanges.length; i++) {
          let value = currentExtensionRanges[i](token, input);
          if (value !== void 0)
            return value;
        }
        return new Tag(input, token);
      }
    case 7:
      switch (token) {
        case 20:
          return false;
        case 21:
          return true;
        case 22:
          return null;
        case 23:
          return;
        // undefined
        case 31:
        default:
          let packedValue = (packedValues || getPackedValues())[token];
          if (packedValue !== void 0)
            return packedValue;
          throw new Error("Unknown token " + token);
      }
    default:
      if (isNaN(token)) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error("Unknown CBOR token " + token);
  }
}
var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
  if (!structure) throw new Error("Structure is required in record definition");
  function readObject() {
    let length = src[position++];
    length = length & 31;
    if (length > 23) {
      switch (length) {
        case 24:
          length = src[position++];
          break;
        case 25:
          length = dataView.getUint16(position);
          position += 2;
          break;
        case 26:
          length = dataView.getUint32(position);
          position += 4;
          break;
        default:
          throw new Error("Expected array header, but got " + src[position - 1]);
      }
    }
    let compiledReader = this.compiledReader;
    while (compiledReader) {
      if (compiledReader.propertyCount === length)
        return compiledReader(read);
      compiledReader = compiledReader.next;
    }
    if (this.slowReads++ >= inlineObjectReadThreshold) {
      let array = this.length == length ? this : this.slice(0, length);
      compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map((key) => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
      if (this.compiledReader)
        compiledReader.next = this.compiledReader;
      compiledReader.propertyCount = length;
      this.compiledReader = compiledReader;
      return compiledReader(read);
    }
    let object = {};
    if (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read();
    else for (let i = 0; i < length; i++) {
      object[safeKey(this[i])] = read();
    }
    return object;
  }
  structure.slowReads = 0;
  return readObject;
}
function safeKey(key) {
  if (typeof key === "string") return key === "__proto__" ? "__proto_" : key;
  if (typeof key === "number" || typeof key === "boolean" || typeof key === "bigint") return key.toString();
  if (key == null) return key + "";
  throw new Error("Invalid property name type " + typeof key);
}
var readFixedString = readStringJS;
function readStringJS(length) {
  let result;
  if (length < 16) {
    if (result = shortStringInJS(length))
      return result;
  }
  if (length > 64 && decoder)
    return decoder.decode(src.subarray(position, position += length));
  const end = position + length;
  const units = [];
  result = "";
  while (position < end) {
    const byte1 = src[position++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      const byte4 = src[position++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
var fromCharCode = String.fromCharCode;
function longStringInJS(length) {
  let start = position;
  let bytes = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0)
        return "";
      else {
        let a = src[position++];
        if ((a & 128) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position -= 2;
        return;
      }
      if (length < 3)
        return fromCharCode(a, b);
      let c = src[position++];
      if ((c & 128) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src[position++];
    let b = src[position++];
    let c = src[position++];
    let d = src[position++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
      position -= 4;
      return;
    }
    if (length < 6) {
      if (length === 4)
        return fromCharCode(a, b, c, d);
      else {
        let e = src[position++];
        if ((e & 128) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length < 8) {
      let e = src[position++];
      let f = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0) {
        position -= 6;
        return;
      }
      if (length < 7)
        return fromCharCode(a, b, c, d, e, f);
      let g = src[position++];
      if ((g & 128) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f, g);
    } else {
      let e = src[position++];
      let f = src[position++];
      let g = src[position++];
      let h = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
        position -= 8;
        return;
      }
      if (length < 10) {
        if (length === 8)
          return fromCharCode(a, b, c, d, e, f, g, h);
        else {
          let i = src[position++];
          if ((i & 128) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i);
        }
      } else if (length < 12) {
        let i = src[position++];
        let j = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position -= 10;
          return;
        }
        if (length < 11)
          return fromCharCode(a, b, c, d, e, f, g, h, i, j);
        let k = src[position++];
        if ((k & 128) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
      } else {
        let i = src[position++];
        let j = src[position++];
        let k = src[position++];
        let l = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position -= 12;
          return;
        }
        if (length < 14) {
          if (length === 12)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
          else {
            let m = src[position++];
            if ((m & 128) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
          }
        } else {
          let m = src[position++];
          let n = src[position++];
          if ((m & 128) > 0 || (n & 128) > 0) {
            position -= 14;
            return;
          }
          if (length < 15)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
          let o = src[position++];
          if ((o & 128) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
function readBin(length) {
  return currentDecoder.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position, position += length)
  ) : src.subarray(position, position += length);
}
var f32Array = new Float32Array(1);
var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function getFloat16() {
  let byte0 = src[position++];
  let byte1 = src[position++];
  let exponent = (byte0 & 127) >> 2;
  if (exponent === 31) {
    if (byte1 || byte0 & 3)
      return NaN;
    return byte0 & 128 ? -Infinity : Infinity;
  }
  if (exponent === 0) {
    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
    return byte0 & 128 ? -abs : abs;
  }
  u8Array[3] = byte0 & 128 | // sign bit
  (exponent >> 1) + 56;
  u8Array[2] = (byte0 & 7) << 5 | // last exponent bit and first two mantissa bits
  byte1 >> 3;
  u8Array[1] = byte1 << 5;
  u8Array[0] = 0;
  return f32Array[0];
}
var keyCache = new Array(4096);
var Tag = class {
  constructor(value, tag) {
    this.value = value;
    this.tag = tag;
  }
};
currentExtensions[0] = (dateString) => {
  return new Date(dateString);
};
currentExtensions[1] = (epochSec) => {
  return new Date(Math.round(epochSec * 1e3));
};
currentExtensions[2] = (buffer) => {
  let value = BigInt(0);
  for (let i = 0, l = buffer.byteLength; i < l; i++) {
    value = BigInt(buffer[i]) + (value << BigInt(8));
  }
  return value;
};
currentExtensions[3] = (buffer) => {
  return BigInt(-1) - currentExtensions[2](buffer);
};
currentExtensions[4] = (fraction) => {
  return +(fraction[1] + "e" + fraction[0]);
};
currentExtensions[5] = (fraction) => {
  return fraction[1] * Math.exp(fraction[0] * Math.log(2));
};
var recordDefinition = (id, structure) => {
  id = id - 57344;
  let existingStructure = currentStructures[id];
  if (existingStructure && existingStructure.isShared) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
  }
  currentStructures[id] = structure;
  structure.read = createStructureReader(structure);
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {
  let length = data.length;
  let structure = data[1];
  recordDefinition(data[0], structure);
  let object = {};
  for (let i = 2; i < length; i++) {
    let key = structure[i - 2];
    object[safeKey(key)] = data[i];
  }
  return object;
};
currentExtensions[14] = (value) => {
  if (bundledStrings)
    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
  return new Tag(value, 14);
};
currentExtensions[15] = (value) => {
  if (bundledStrings)
    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
  return new Tag(value, 15);
};
var glbl = { Error, RegExp };
currentExtensions[27] = (data) => {
  return (glbl[data[0]] || Error)(data[1], data[2]);
};
var packedTable = (read2) => {
  if (src[position++] != 132) {
    let error = new Error("Packed values structure must be followed by a 4 element array");
    if (src.length < position)
      error.incomplete = true;
    throw error;
  }
  let newPackedValues = read2();
  if (!newPackedValues || !newPackedValues.length) {
    let error = new Error("Packed values structure must be followed by a 4 element array");
    error.incomplete = true;
    throw error;
  }
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = read2();
  packedValues.suffixes = read2();
  return read2();
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;
currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
  if (!packedValues) {
    if (currentDecoder.getShared)
      loadShared();
    else
      return new Tag(data, PACKED_REFERENCE_TAG_ID);
  }
  if (typeof data == "number")
    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
  let error = new Error("No support for non-integer packed references yet");
  if (data === void 0)
    error.incomplete = true;
  throw error;
};
currentExtensions[28] = (read2) => {
  if (!referenceMap) {
    referenceMap = /* @__PURE__ */ new Map();
    referenceMap.id = 0;
  }
  let id = referenceMap.id++;
  let startingPosition = position;
  let token = src[position];
  let target2;
  if (token >> 5 == 4)
    target2 = [];
  else
    target2 = {};
  let refEntry = { target: target2 };
  referenceMap.set(id, refEntry);
  let targetProperties = read2();
  if (refEntry.used) {
    if (Object.getPrototypeOf(target2) !== Object.getPrototypeOf(targetProperties)) {
      position = startingPosition;
      target2 = targetProperties;
      referenceMap.set(id, { target: target2 });
      targetProperties = read2();
    }
    return Object.assign(target2, targetProperties);
  }
  refEntry.target = targetProperties;
  return targetProperties;
};
currentExtensions[28].handlesRead = true;
currentExtensions[29] = (id) => {
  let refEntry = referenceMap.get(id);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[258] = (array) => new Set(array);
(currentExtensions[259] = (read2) => {
  if (currentDecoder.mapsAsObjects) {
    currentDecoder.mapsAsObjects = false;
    restoreMapsAsObject = true;
  }
  return read2();
}).handlesRead = true;
function combine(a, b) {
  if (typeof a === "string")
    return a + b;
  if (a instanceof Array)
    return a.concat(b);
  return Object.assign({}, a, b);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared)
      loadShared();
    else
      throw new Error("No packed values available");
  }
  return packedValues;
}
var SHARED_DATA_TAG_ID = 1399353956;
currentExtensionRanges.push((tag, input) => {
  if (tag >= 225 && tag <= 255)
    return combine(getPackedValues().prefixes[tag - 224], input);
  if (tag >= 28704 && tag <= 32767)
    return combine(getPackedValues().prefixes[tag - 28672], input);
  if (tag >= 1879052288 && tag <= 2147483647)
    return combine(getPackedValues().prefixes[tag - 1879048192], input);
  if (tag >= 216 && tag <= 223)
    return combine(input, getPackedValues().suffixes[tag - 216]);
  if (tag >= 27647 && tag <= 28671)
    return combine(input, getPackedValues().suffixes[tag - 27639]);
  if (tag >= 1811940352 && tag <= 1879048191)
    return combine(input, getPackedValues().suffixes[tag - 1811939328]);
  if (tag == SHARED_DATA_TAG_ID) {
    return {
      packedValues,
      structures: currentStructures.slice(0),
      version: input
    };
  }
  if (tag == 55799)
    return input;
});
var isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
var typedArrays = [
  Uint8Array,
  Uint8ClampedArray,
  Uint16Array,
  Uint32Array,
  typeof BigUint64Array == "undefined" ? { name: "BigUint64Array" } : BigUint64Array,
  Int8Array,
  Int16Array,
  Int32Array,
  typeof BigInt64Array == "undefined" ? { name: "BigInt64Array" } : BigInt64Array,
  Float32Array,
  Float64Array
];
var typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
for (let i = 0; i < typedArrays.length; i++) {
  registerTypedArray(typedArrays[i], typedArrayTags[i]);
}
function registerTypedArray(TypedArray, tag) {
  let dvMethod = "get" + TypedArray.name.slice(0, -5);
  let bytesPerElement;
  if (typeof TypedArray === "function")
    bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
  else
    TypedArray = null;
  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
    if (!littleEndian && bytesPerElement == 1)
      continue;
    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : bytesPerElement == 8 ? 3 : 0;
    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer) => {
      if (!TypedArray)
        throw new Error("Could not find typed array for code " + tag);
      if (!currentDecoder.copyBuffers) {
        if (bytesPerElement === 1 || bytesPerElement === 2 && !(buffer.byteOffset & 1) || bytesPerElement === 4 && !(buffer.byteOffset & 3) || bytesPerElement === 8 && !(buffer.byteOffset & 7))
          return new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift);
      }
      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
    } : (buffer) => {
      if (!TypedArray)
        throw new Error("Could not find typed array for code " + tag);
      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      let elements = buffer.length >> sizeShift;
      let ta = new TypedArray(elements);
      let method = dv[dvMethod];
      for (let i = 0; i < elements; i++) {
        ta[i] = method.call(dv, i << sizeShift, littleEndian);
      }
      return ta;
    };
  }
}
function readBundleExt() {
  let length = readJustLength();
  let bundlePosition = position + read();
  for (let i = 2; i < length; i++) {
    let bundleLength = readJustLength();
    position += bundleLength;
  }
  let dataPosition = position;
  position = bundlePosition;
  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read();
}
function readJustLength() {
  let token = src[position++] & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        token = dataView.getUint32(position);
        position += 4;
        break;
    }
  }
  return token;
}
function loadShared() {
  if (currentDecoder.getShared) {
    let sharedData = saveState(() => {
      src = null;
      return currentDecoder.getShared();
    }) || {};
    let updatedStructures = sharedData.structures || [];
    currentDecoder.sharedVersion = sharedData.version;
    packedValues = currentDecoder.sharedValues = sharedData.packedValues;
    if (currentStructures === true)
      currentDecoder.structures = currentStructures = updatedStructures;
    else
      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
  }
}
function saveState(callback) {
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedStringPosition = stringPosition;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedStrings = strings;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;
  let savedSrc = new Uint8Array(src.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedDecoder = currentDecoder;
  let savedSequentialMode = sequentialMode;
  let value = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  stringPosition = savedStringPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  strings = savedStrings;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentDecoder = savedDecoder;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
var mult10 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
}
var defaultDecoder = new Decoder({ useRecords: false });
var decode = defaultDecoder.decode;
var decodeMultiple = defaultDecoder.decodeMultiple;
var FLOAT32_OPTIONS = {
  NEVER: 0,
  ALWAYS: 1,
  DECIMAL_ROUND: 3,
  DECIMAL_FIT: 4
};

// node_modules/cbor-x/encode.js
var textEncoder;
try {
  textEncoder = new TextEncoder();
} catch (error) {
}
var extensions;
var extensionClasses;
var Buffer2 = typeof globalThis === "object" && globalThis.Buffer;
var hasNodeBuffer = typeof Buffer2 !== "undefined";
var ByteArrayAllocate = hasNodeBuffer ? Buffer2.allocUnsafeSlow : Uint8Array;
var ByteArray = hasNodeBuffer ? Buffer2 : Uint8Array;
var MAX_STRUCTURES = 256;
var MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
var throwOnIterable;
var target;
var targetView;
var position2 = 0;
var safeEnd;
var bundledStrings2 = null;
var MAX_BUNDLE_SIZE = 61440;
var hasNonLatin = /[\u0080-\uFFFF]/;
var RECORD_SYMBOL = Symbol("record-id");
var Encoder = class extends Decoder {
  constructor(options) {
    super(options);
    this.offset = 0;
    let typeBuffer;
    let start;
    let sharedStructures;
    let hasSharedUpdate;
    let structures;
    let referenceMap2;
    options = options || {};
    let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position3, maxBytes) {
      return target.utf8Write(string, position3, maxBytes);
    } : textEncoder && textEncoder.encodeInto ? function(string, position3) {
      return textEncoder.encodeInto(string, target.subarray(position3)).written;
    } : false;
    let encoder = this;
    let hasSharedStructures = options.structures || options.saveStructures;
    let maxSharedStructures = options.maxSharedStructures;
    if (maxSharedStructures == null)
      maxSharedStructures = hasSharedStructures ? 128 : 0;
    if (maxSharedStructures > 8190)
      throw new Error("Maximum maxSharedStructure is 8190");
    let isSequential = options.sequential;
    if (isSequential) {
      maxSharedStructures = 0;
    }
    if (!this.structures)
      this.structures = [];
    if (this.saveStructures)
      this.saveShared = this.saveStructures;
    let samplingPackedValues, packedObjectMap2, sharedValues = options.sharedValues;
    let sharedPackedObjectMap2;
    if (sharedValues) {
      sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
      for (let i = 0, l = sharedValues.length; i < l; i++) {
        sharedPackedObjectMap2[sharedValues[i]] = i;
      }
    }
    let recordIdsToRemove = [];
    let transitionsCount = 0;
    let serializationsSinceTransitionRebuild = 0;
    this.mapEncode = function(value, encodeOptions) {
      if (this._keyMap && !this._mapped) {
        switch (value.constructor.name) {
          case "Array":
            value = value.map((r) => this.encodeKeys(r));
            break;
        }
      }
      return this.encode(value, encodeOptions);
    };
    this.encode = function(value, encodeOptions) {
      if (!target) {
        target = new ByteArrayAllocate(8192);
        targetView = new DataView(target.buffer, 0, 8192);
        position2 = 0;
      }
      safeEnd = target.length - 10;
      if (safeEnd - position2 < 2048) {
        target = new ByteArrayAllocate(target.length);
        targetView = new DataView(target.buffer, 0, target.length);
        safeEnd = target.length - 10;
        position2 = 0;
      } else if (encodeOptions === REUSE_BUFFER_MODE)
        position2 = position2 + 7 & 2147483640;
      start = position2;
      if (encoder.useSelfDescribedHeader) {
        targetView.setUint32(position2, 3654940416);
        position2 += 3;
      }
      referenceMap2 = encoder.structuredClone ? /* @__PURE__ */ new Map() : null;
      if (encoder.bundleStrings && typeof value !== "string") {
        bundledStrings2 = [];
        bundledStrings2.size = Infinity;
      } else
        bundledStrings2 = null;
      sharedStructures = encoder.structures;
      if (sharedStructures) {
        if (sharedStructures.uninitialized) {
          let sharedData = encoder.getShared() || {};
          encoder.structures = sharedStructures = sharedData.structures || [];
          encoder.sharedVersion = sharedData.version;
          let sharedValues2 = encoder.sharedValues = sharedData.packedValues;
          if (sharedValues2) {
            sharedPackedObjectMap2 = {};
            for (let i = 0, l = sharedValues2.length; i < l; i++)
              sharedPackedObjectMap2[sharedValues2[i]] = i;
          }
        }
        let sharedStructuresLength = sharedStructures.length;
        if (sharedStructuresLength > maxSharedStructures && !isSequential)
          sharedStructuresLength = maxSharedStructures;
        if (!sharedStructures.transitions) {
          sharedStructures.transitions = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < sharedStructuresLength; i++) {
            let keys = sharedStructures[i];
            if (!keys)
              continue;
            let nextTransition, transition = sharedStructures.transitions;
            for (let j = 0, l = keys.length; j < l; j++) {
              if (transition[RECORD_SYMBOL] === void 0)
                transition[RECORD_SYMBOL] = i;
              let key = keys[j];
              nextTransition = transition[key];
              if (!nextTransition) {
                nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              }
              transition = nextTransition;
            }
            transition[RECORD_SYMBOL] = i | 1048576;
          }
        }
        if (!isSequential)
          sharedStructures.nextId = sharedStructuresLength;
      }
      if (hasSharedUpdate)
        hasSharedUpdate = false;
      structures = sharedStructures || [];
      packedObjectMap2 = sharedPackedObjectMap2;
      if (options.pack) {
        let packedValues2 = /* @__PURE__ */ new Map();
        packedValues2.values = [];
        packedValues2.encoder = encoder;
        packedValues2.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap2 ? 16 : Infinity);
        packedValues2.objectMap = sharedPackedObjectMap2 || false;
        packedValues2.samplingPackedValues = samplingPackedValues;
        findRepetitiveStrings(value, packedValues2);
        if (packedValues2.values.length > 0) {
          target[position2++] = 216;
          target[position2++] = 51;
          writeArrayHeader(4);
          let valuesArray = packedValues2.values;
          encode2(valuesArray);
          writeArrayHeader(0);
          writeArrayHeader(0);
          packedObjectMap2 = Object.create(sharedPackedObjectMap2 || null);
          for (let i = 0, l = valuesArray.length; i < l; i++) {
            packedObjectMap2[valuesArray[i]] = i;
          }
        }
      }
      throwOnIterable = encodeOptions & THROW_ON_ITERABLE;
      try {
        if (throwOnIterable)
          return;
        encode2(value);
        if (bundledStrings2) {
          writeBundles(start, encode2);
        }
        encoder.offset = position2;
        if (referenceMap2 && referenceMap2.idsToInsert) {
          position2 += referenceMap2.idsToInsert.length * 2;
          if (position2 > safeEnd)
            makeRoom(position2);
          encoder.offset = position2;
          let serialized = insertIds(target.subarray(start, position2), referenceMap2.idsToInsert);
          referenceMap2 = null;
          return serialized;
        }
        if (encodeOptions & REUSE_BUFFER_MODE) {
          target.start = start;
          target.end = position2;
          return target;
        }
        return target.subarray(start, position2);
      } finally {
        if (sharedStructures) {
          if (serializationsSinceTransitionRebuild < 10)
            serializationsSinceTransitionRebuild++;
          if (sharedStructures.length > maxSharedStructures)
            sharedStructures.length = maxSharedStructures;
          if (transitionsCount > 1e4) {
            sharedStructures.transitions = null;
            serializationsSinceTransitionRebuild = 0;
            transitionsCount = 0;
            if (recordIdsToRemove.length > 0)
              recordIdsToRemove = [];
          } else if (recordIdsToRemove.length > 0 && !isSequential) {
            for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
              recordIdsToRemove[i][RECORD_SYMBOL] = void 0;
            }
            recordIdsToRemove = [];
          }
        }
        if (hasSharedUpdate && encoder.saveShared) {
          if (encoder.structures.length > maxSharedStructures) {
            encoder.structures = encoder.structures.slice(0, maxSharedStructures);
          }
          let returnBuffer = target.subarray(start, position2);
          if (encoder.updateSharedData() === false)
            return encoder.encode(value);
          return returnBuffer;
        }
        if (encodeOptions & RESET_BUFFER_MODE)
          position2 = start;
      }
    };
    this.findCommonStringsToPack = () => {
      samplingPackedValues = /* @__PURE__ */ new Map();
      if (!sharedPackedObjectMap2)
        sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
      return (options2) => {
        let threshold = options2 && options2.threshold || 4;
        let position3 = this.pack ? options2.maxPrivatePackedValues || 16 : 0;
        if (!sharedValues)
          sharedValues = this.sharedValues = [];
        for (let [key, status] of samplingPackedValues) {
          if (status.count > threshold) {
            sharedPackedObjectMap2[key] = position3++;
            sharedValues.push(key);
            hasSharedUpdate = true;
          }
        }
        while (this.saveShared && this.updateSharedData() === false) {
        }
        samplingPackedValues = null;
      };
    };
    const encode2 = (value) => {
      if (position2 > safeEnd)
        target = makeRoom(position2);
      var type = typeof value;
      var length;
      if (type === "string") {
        if (packedObjectMap2) {
          let packedPosition = packedObjectMap2[value];
          if (packedPosition >= 0) {
            if (packedPosition < 16)
              target[position2++] = packedPosition + 224;
            else {
              target[position2++] = 198;
              if (packedPosition & 1)
                encode2(15 - packedPosition >> 1);
              else
                encode2(packedPosition - 16 >> 1);
            }
            return;
          } else if (samplingPackedValues && !options.pack) {
            let status = samplingPackedValues.get(value);
            if (status)
              status.count++;
            else
              samplingPackedValues.set(value, {
                count: 1
              });
          }
        }
        let strLength = value.length;
        if (bundledStrings2 && strLength >= 4 && strLength < 1024) {
          if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
            let extStart;
            let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
            if (position2 + maxBytes2 > safeEnd)
              target = makeRoom(position2 + maxBytes2);
            target[position2++] = 217;
            target[position2++] = 223;
            target[position2++] = 249;
            target[position2++] = bundledStrings2.position ? 132 : 130;
            target[position2++] = 26;
            extStart = position2 - start;
            position2 += 4;
            if (bundledStrings2.position) {
              writeBundles(start, encode2);
            }
            bundledStrings2 = ["", ""];
            bundledStrings2.size = 0;
            bundledStrings2.position = extStart;
          }
          let twoByte = hasNonLatin.test(value);
          bundledStrings2[twoByte ? 0 : 1] += value;
          target[position2++] = twoByte ? 206 : 207;
          encode2(strLength);
          return;
        }
        let headerSize;
        if (strLength < 32) {
          headerSize = 1;
        } else if (strLength < 256) {
          headerSize = 2;
        } else if (strLength < 65536) {
          headerSize = 3;
        } else {
          headerSize = 5;
        }
        let maxBytes = strLength * 3;
        if (position2 + maxBytes > safeEnd)
          target = makeRoom(position2 + maxBytes);
        if (strLength < 64 || !encodeUtf8) {
          let i, c1, c2, strPosition = position2 + headerSize;
          for (i = 0; i < strLength; i++) {
            c1 = value.charCodeAt(i);
            if (c1 < 128) {
              target[strPosition++] = c1;
            } else if (c1 < 2048) {
              target[strPosition++] = c1 >> 6 | 192;
              target[strPosition++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              i++;
              target[strPosition++] = c1 >> 18 | 240;
              target[strPosition++] = c1 >> 12 & 63 | 128;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            } else {
              target[strPosition++] = c1 >> 12 | 224;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            }
          }
          length = strPosition - position2 - headerSize;
        } else {
          length = encodeUtf8(value, position2 + headerSize, maxBytes);
        }
        if (length < 24) {
          target[position2++] = 96 | length;
        } else if (length < 256) {
          if (headerSize < 2) {
            target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length);
          }
          target[position2++] = 120;
          target[position2++] = length;
        } else if (length < 65536) {
          if (headerSize < 3) {
            target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length);
          }
          target[position2++] = 121;
          target[position2++] = length >> 8;
          target[position2++] = length & 255;
        } else {
          if (headerSize < 5) {
            target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length);
          }
          target[position2++] = 122;
          targetView.setUint32(position2, length);
          position2 += 4;
        }
        position2 += length;
      } else if (type === "number") {
        if (!this.alwaysUseFloat && value >>> 0 === value) {
          if (value < 24) {
            target[position2++] = value;
          } else if (value < 256) {
            target[position2++] = 24;
            target[position2++] = value;
          } else if (value < 65536) {
            target[position2++] = 25;
            target[position2++] = value >> 8;
            target[position2++] = value & 255;
          } else {
            target[position2++] = 26;
            targetView.setUint32(position2, value);
            position2 += 4;
          }
        } else if (!this.alwaysUseFloat && value >> 0 === value) {
          if (value >= -24) {
            target[position2++] = 31 - value;
          } else if (value >= -256) {
            target[position2++] = 56;
            target[position2++] = ~value;
          } else if (value >= -65536) {
            target[position2++] = 57;
            targetView.setUint16(position2, ~value);
            position2 += 2;
          } else {
            target[position2++] = 58;
            targetView.setUint32(position2, ~value);
            position2 += 4;
          }
        } else {
          let useFloat32;
          if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
            target[position2++] = 250;
            targetView.setFloat32(position2, value);
            let xShifted;
            if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
            (xShifted = value * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
              position2 += 4;
              return;
            } else
              position2--;
          }
          target[position2++] = 251;
          targetView.setFloat64(position2, value);
          position2 += 8;
        }
      } else if (type === "object") {
        if (!value)
          target[position2++] = 246;
        else {
          if (referenceMap2) {
            let referee = referenceMap2.get(value);
            if (referee) {
              target[position2++] = 216;
              target[position2++] = 29;
              target[position2++] = 25;
              if (!referee.references) {
                let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                referee.references = [];
                idsToInsert.push(referee);
              }
              referee.references.push(position2 - start);
              position2 += 2;
              return;
            } else
              referenceMap2.set(value, { offset: position2 - start });
          }
          let constructor = value.constructor;
          if (constructor === Object) {
            writeObject(value);
          } else if (constructor === Array) {
            length = value.length;
            if (length < 24) {
              target[position2++] = 128 | length;
            } else {
              writeArrayHeader(length);
            }
            for (let i = 0; i < length; i++) {
              encode2(value[i]);
            }
          } else if (constructor === Map) {
            if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
              target[position2++] = 217;
              target[position2++] = 1;
              target[position2++] = 3;
            }
            length = value.size;
            if (length < 24) {
              target[position2++] = 160 | length;
            } else if (length < 256) {
              target[position2++] = 184;
              target[position2++] = length;
            } else if (length < 65536) {
              target[position2++] = 185;
              target[position2++] = length >> 8;
              target[position2++] = length & 255;
            } else {
              target[position2++] = 186;
              targetView.setUint32(position2, length);
              position2 += 4;
            }
            if (encoder.keyMap) {
              for (let [key, entryValue] of value) {
                encode2(encoder.encodeKey(key));
                encode2(entryValue);
              }
            } else {
              for (let [key, entryValue] of value) {
                encode2(key);
                encode2(entryValue);
              }
            }
          } else {
            for (let i = 0, l = extensions.length; i < l; i++) {
              let extensionClass = extensionClasses[i];
              if (value instanceof extensionClass) {
                let extension = extensions[i];
                let tag = extension.tag;
                if (tag == void 0)
                  tag = extension.getTag && extension.getTag.call(this, value);
                if (tag < 24) {
                  target[position2++] = 192 | tag;
                } else if (tag < 256) {
                  target[position2++] = 216;
                  target[position2++] = tag;
                } else if (tag < 65536) {
                  target[position2++] = 217;
                  target[position2++] = tag >> 8;
                  target[position2++] = tag & 255;
                } else if (tag > -1) {
                  target[position2++] = 218;
                  targetView.setUint32(position2, tag);
                  position2 += 4;
                }
                extension.encode.call(this, value, encode2, makeRoom);
                return;
              }
            }
            if (value[Symbol.iterator]) {
              if (throwOnIterable) {
                let error = new Error("Iterable should be serialized as iterator");
                error.iteratorNotHandled = true;
                throw error;
              }
              target[position2++] = 159;
              for (let entry of value) {
                encode2(entry);
              }
              target[position2++] = 255;
              return;
            }
            if (value[Symbol.asyncIterator] || isBlob(value)) {
              let error = new Error("Iterable/blob should be serialized as iterator");
              error.iteratorNotHandled = true;
              throw error;
            }
            if (this.useToJSON && value.toJSON) {
              const json = value.toJSON();
              if (json !== value)
                return encode2(json);
            }
            writeObject(value);
          }
        }
      } else if (type === "boolean") {
        target[position2++] = value ? 245 : 244;
      } else if (type === "bigint") {
        if (value < BigInt(1) << BigInt(64) && value >= 0) {
          target[position2++] = 27;
          targetView.setBigUint64(position2, value);
        } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
          target[position2++] = 59;
          targetView.setBigUint64(position2, -value - BigInt(1));
        } else {
          if (this.largeBigIntToFloat) {
            target[position2++] = 251;
            targetView.setFloat64(position2, Number(value));
          } else {
            if (value >= BigInt(0))
              target[position2++] = 194;
            else {
              target[position2++] = 195;
              value = BigInt(-1) - value;
            }
            let bytes = [];
            while (value) {
              bytes.push(Number(value & BigInt(255)));
              value >>= BigInt(8);
            }
            writeBuffer(new Uint8Array(bytes.reverse()), makeRoom);
            return;
          }
        }
        position2 += 8;
      } else if (type === "undefined") {
        target[position2++] = 247;
      } else {
        throw new Error("Unknown type: " + type);
      }
    };
    const writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {
      let keys = Object.keys(object);
      let vals = Object.values(object);
      let length = keys.length;
      if (length < 24) {
        target[position2++] = 160 | length;
      } else if (length < 256) {
        target[position2++] = 184;
        target[position2++] = length;
      } else if (length < 65536) {
        target[position2++] = 185;
        target[position2++] = length >> 8;
        target[position2++] = length & 255;
      } else {
        target[position2++] = 186;
        targetView.setUint32(position2, length);
        position2 += 4;
      }
      let key;
      if (encoder.keyMap) {
        for (let i = 0; i < length; i++) {
          encode2(encoder.encodeKey(keys[i]));
          encode2(vals[i]);
        }
      } else {
        for (let i = 0; i < length; i++) {
          encode2(keys[i]);
          encode2(vals[i]);
        }
      }
    } : (object) => {
      target[position2++] = 185;
      let objectOffset = position2 - start;
      position2 += 2;
      let size = 0;
      if (encoder.keyMap) {
        for (let key in object) if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
          encode2(encoder.encodeKey(key));
          encode2(object[key]);
          size++;
        }
      } else {
        for (let key in object) if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
          encode2(key);
          encode2(object[key]);
          size++;
        }
      }
      target[objectOffset++ + start] = size >> 8;
      target[objectOffset + start] = size & 255;
    } : (object, skipValues) => {
      let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
      let newTransitions = 0;
      let length = 0;
      let parentRecordId;
      let keys;
      if (this.keyMap) {
        keys = Object.keys(object).map((k) => this.encodeKey(k));
        length = keys.length;
        for (let i = 0; i < length; i++) {
          let key = keys[i];
          nextTransition = transition[key];
          if (!nextTransition) {
            nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
            newTransitions++;
          }
          transition = nextTransition;
        }
      } else {
        for (let key in object) if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
          nextTransition = transition[key];
          if (!nextTransition) {
            if (transition[RECORD_SYMBOL] & 1048576) {
              parentRecordId = transition[RECORD_SYMBOL] & 65535;
            }
            nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
            newTransitions++;
          }
          transition = nextTransition;
          length++;
        }
      }
      let recordId = transition[RECORD_SYMBOL];
      if (recordId !== void 0) {
        recordId &= 65535;
        target[position2++] = 217;
        target[position2++] = recordId >> 8 | 224;
        target[position2++] = recordId & 255;
      } else {
        if (!keys)
          keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));
        if (parentRecordId === void 0) {
          recordId = structures.nextId++;
          if (!recordId) {
            recordId = 0;
            structures.nextId = 1;
          }
          if (recordId >= MAX_STRUCTURES) {
            structures.nextId = (recordId = maxSharedStructures) + 1;
          }
        } else {
          recordId = parentRecordId;
        }
        structures[recordId] = keys;
        if (recordId < maxSharedStructures) {
          target[position2++] = 217;
          target[position2++] = recordId >> 8 | 224;
          target[position2++] = recordId & 255;
          transition = structures.transitions;
          for (let i = 0; i < length; i++) {
            if (transition[RECORD_SYMBOL] === void 0 || transition[RECORD_SYMBOL] & 1048576)
              transition[RECORD_SYMBOL] = recordId;
            transition = transition[keys[i]];
          }
          transition[RECORD_SYMBOL] = recordId | 1048576;
          hasSharedUpdate = true;
        } else {
          transition[RECORD_SYMBOL] = recordId;
          targetView.setUint32(position2, 3655335680);
          position2 += 3;
          if (newTransitions)
            transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
          if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)
            recordIdsToRemove.shift()[RECORD_SYMBOL] = void 0;
          recordIdsToRemove.push(transition);
          writeArrayHeader(length + 2);
          encode2(57344 + recordId);
          encode2(keys);
          if (skipValues) return;
          for (let key in object)
            if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key))
              encode2(object[key]);
          return;
        }
      }
      if (length < 24) {
        target[position2++] = 128 | length;
      } else {
        writeArrayHeader(length);
      }
      if (skipValues) return;
      for (let key in object)
        if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key))
          encode2(object[key]);
    };
    const makeRoom = (end) => {
      let newSize;
      if (end > 16777216) {
        if (end - start > MAX_BUFFER_SIZE)
          throw new Error("Encoded buffer would be larger than maximum buffer size");
        newSize = Math.min(
          MAX_BUFFER_SIZE,
          Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
        );
      } else
        newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
      let newBuffer = new ByteArrayAllocate(newSize);
      targetView = new DataView(newBuffer.buffer, 0, newSize);
      if (target.copy)
        target.copy(newBuffer, 0, start, end);
      else
        newBuffer.set(target.slice(start, end));
      position2 -= start;
      start = 0;
      safeEnd = newBuffer.length - 10;
      return target = newBuffer;
    };
    let chunkThreshold = 100;
    let continuedChunkThreshold = 1e3;
    this.encodeAsIterable = function(value, options2) {
      return startEncoding(value, options2, encodeObjectAsIterable);
    };
    this.encodeAsAsyncIterable = function(value, options2) {
      return startEncoding(value, options2, encodeObjectAsAsyncIterable);
    };
    function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {
      let constructor = object.constructor;
      if (constructor === Object) {
        let useRecords = encoder.useRecords !== false;
        if (useRecords)
          writeObject(object, true);
        else
          writeEntityLength(Object.keys(object).length, 160);
        for (let key in object) {
          let value = object[key];
          if (!useRecords) encode2(key);
          if (value && typeof value === "object") {
            if (iterateProperties[key])
              yield* encodeObjectAsIterable(value, iterateProperties[key]);
            else
              yield* tryEncode(value, iterateProperties, key);
          } else encode2(value);
        }
      } else if (constructor === Array) {
        let length = object.length;
        writeArrayHeader(length);
        for (let i = 0; i < length; i++) {
          let value = object[i];
          if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
            if (iterateProperties.element)
              yield* encodeObjectAsIterable(value, iterateProperties.element);
            else
              yield* tryEncode(value, iterateProperties, "element");
          } else encode2(value);
        }
      } else if (object[Symbol.iterator] && !object.buffer) {
        target[position2++] = 159;
        for (let value of object) {
          if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
            if (iterateProperties.element)
              yield* encodeObjectAsIterable(value, iterateProperties.element);
            else
              yield* tryEncode(value, iterateProperties, "element");
          } else encode2(value);
        }
        target[position2++] = 255;
      } else if (isBlob(object)) {
        writeEntityLength(object.size, 64);
        yield target.subarray(start, position2);
        yield object;
        restartEncoding();
      } else if (object[Symbol.asyncIterator]) {
        target[position2++] = 159;
        yield target.subarray(start, position2);
        yield object;
        restartEncoding();
        target[position2++] = 255;
      } else {
        encode2(object);
      }
      if (finalIterable && position2 > start) yield target.subarray(start, position2);
      else if (position2 - start > chunkThreshold) {
        yield target.subarray(start, position2);
        restartEncoding();
      }
    }
    function* tryEncode(value, iterateProperties, key) {
      let restart = position2 - start;
      try {
        encode2(value);
        if (position2 - start > chunkThreshold) {
          yield target.subarray(start, position2);
          restartEncoding();
        }
      } catch (error) {
        if (error.iteratorNotHandled) {
          iterateProperties[key] = {};
          position2 = start + restart;
          yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);
        } else throw error;
      }
    }
    function restartEncoding() {
      chunkThreshold = continuedChunkThreshold;
      encoder.encode(null, THROW_ON_ITERABLE);
    }
    function startEncoding(value, options2, encodeIterable) {
      if (options2 && options2.chunkThreshold)
        chunkThreshold = continuedChunkThreshold = options2.chunkThreshold;
      else
        chunkThreshold = 100;
      if (value && typeof value === "object") {
        encoder.encode(null, THROW_ON_ITERABLE);
        return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);
      }
      return [encoder.encode(value)];
    }
    async function* encodeObjectAsAsyncIterable(value, iterateProperties) {
      for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
        let constructor = encodedValue.constructor;
        if (constructor === ByteArray || constructor === Uint8Array)
          yield encodedValue;
        else if (isBlob(encodedValue)) {
          let reader = encodedValue.stream().getReader();
          let next;
          while (!(next = await reader.read()).done) {
            yield next.value;
          }
        } else if (encodedValue[Symbol.asyncIterator]) {
          for await (let asyncValue of encodedValue) {
            restartEncoding();
            if (asyncValue)
              yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));
            else yield encoder.encode(asyncValue);
          }
        } else {
          yield encodedValue;
        }
      }
    }
  }
  useBuffer(buffer) {
    target = buffer;
    targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
    position2 = 0;
  }
  clearSharedData() {
    if (this.structures)
      this.structures = [];
    if (this.sharedValues)
      this.sharedValues = void 0;
  }
  updateSharedData() {
    let lastVersion = this.sharedVersion || 0;
    this.sharedVersion = lastVersion + 1;
    let structuresCopy = this.structures.slice(0);
    let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
    let saveResults = this.saveShared(
      sharedData,
      (existingShared) => (existingShared && existingShared.version || 0) == lastVersion
    );
    if (saveResults === false) {
      sharedData = this.getShared() || {};
      this.structures = sharedData.structures || [];
      this.sharedValues = sharedData.packedValues;
      this.sharedVersion = sharedData.version;
      this.structures.nextId = this.structures.length;
    } else {
      structuresCopy.forEach((structure, i) => this.structures[i] = structure);
    }
    return saveResults;
  }
};
function writeEntityLength(length, majorValue) {
  if (length < 24)
    target[position2++] = majorValue | length;
  else if (length < 256) {
    target[position2++] = majorValue | 24;
    target[position2++] = length;
  } else if (length < 65536) {
    target[position2++] = majorValue | 25;
    target[position2++] = length >> 8;
    target[position2++] = length & 255;
  } else {
    target[position2++] = majorValue | 26;
    targetView.setUint32(position2, length);
    position2 += 4;
  }
}
var SharedData = class {
  constructor(structures, values, version) {
    this.structures = structures;
    this.packedValues = values;
    this.version = version;
  }
};
function writeArrayHeader(length) {
  if (length < 24)
    target[position2++] = 128 | length;
  else if (length < 256) {
    target[position2++] = 152;
    target[position2++] = length;
  } else if (length < 65536) {
    target[position2++] = 153;
    target[position2++] = length >> 8;
    target[position2++] = length & 255;
  } else {
    target[position2++] = 154;
    targetView.setUint32(position2, length);
    position2 += 4;
  }
}
var BlobConstructor = typeof Blob === "undefined" ? function() {
} : Blob;
function isBlob(object) {
  if (object instanceof BlobConstructor)
    return true;
  let tag = object[Symbol.toStringTag];
  return tag === "Blob" || tag === "File";
}
function findRepetitiveStrings(value, packedValues2) {
  switch (typeof value) {
    case "string":
      if (value.length > 3) {
        if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues)
          return;
        let packedStatus = packedValues2.get(value);
        if (packedStatus) {
          if (++packedStatus.count == 2) {
            packedValues2.values.push(value);
          }
        } else {
          packedValues2.set(value, {
            count: 1
          });
          if (packedValues2.samplingPackedValues) {
            let status = packedValues2.samplingPackedValues.get(value);
            if (status)
              status.count++;
            else
              packedValues2.samplingPackedValues.set(value, {
                count: 1
              });
          }
        }
      }
      break;
    case "object":
      if (value) {
        if (value instanceof Array) {
          for (let i = 0, l = value.length; i < l; i++) {
            findRepetitiveStrings(value[i], packedValues2);
          }
        } else {
          let includeKeys = !packedValues2.encoder.useRecords;
          for (var key in value) {
            if (value.hasOwnProperty(key)) {
              if (includeKeys)
                findRepetitiveStrings(key, packedValues2);
              findRepetitiveStrings(value[key], packedValues2);
            }
          }
        }
      }
      break;
    case "function":
      console.log(value);
  }
}
var isLittleEndianMachine2 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
extensionClasses = [
  Date,
  Set,
  Error,
  RegExp,
  Tag,
  ArrayBuffer,
  Uint8Array,
  Uint8ClampedArray,
  Uint16Array,
  Uint32Array,
  typeof BigUint64Array == "undefined" ? function() {
  } : BigUint64Array,
  Int8Array,
  Int16Array,
  Int32Array,
  typeof BigInt64Array == "undefined" ? function() {
  } : BigInt64Array,
  Float32Array,
  Float64Array,
  SharedData
];
extensions = [
  {
    // Date
    tag: 1,
    encode(date, encode2) {
      let seconds = date.getTime() / 1e3;
      if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
        target[position2++] = 26;
        targetView.setUint32(position2, seconds);
        position2 += 4;
      } else {
        target[position2++] = 251;
        targetView.setFloat64(position2, seconds);
        position2 += 8;
      }
    }
  },
  {
    // Set
    tag: 258,
    // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
    encode(set, encode2) {
      let array = Array.from(set);
      encode2(array);
    }
  },
  {
    // Error
    tag: 27,
    // http://cbor.schmorp.de/generic-object
    encode(error, encode2) {
      encode2([error.name, error.message]);
    }
  },
  {
    // RegExp
    tag: 27,
    // http://cbor.schmorp.de/generic-object
    encode(regex, encode2) {
      encode2(["RegExp", regex.source, regex.flags]);
    }
  },
  {
    // Tag
    getTag(tag) {
      return tag.tag;
    },
    encode(tag, encode2) {
      encode2(tag.value);
    }
  },
  {
    // ArrayBuffer
    encode(arrayBuffer, encode2, makeRoom) {
      writeBuffer(arrayBuffer, makeRoom);
    }
  },
  {
    // Uint8Array
    getTag(typedArray) {
      if (typedArray.constructor === Uint8Array) {
        if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)
          return 64;
      }
    },
    encode(typedArray, encode2, makeRoom) {
      writeBuffer(typedArray, makeRoom);
    }
  },
  typedArrayEncoder(68, 1),
  typedArrayEncoder(69, 2),
  typedArrayEncoder(70, 4),
  typedArrayEncoder(71, 8),
  typedArrayEncoder(72, 1),
  typedArrayEncoder(77, 2),
  typedArrayEncoder(78, 4),
  typedArrayEncoder(79, 8),
  typedArrayEncoder(85, 4),
  typedArrayEncoder(86, 8),
  {
    encode(sharedData, encode2) {
      let packedValues2 = sharedData.packedValues || [];
      let sharedStructures = sharedData.structures || [];
      if (packedValues2.values.length > 0) {
        target[position2++] = 216;
        target[position2++] = 51;
        writeArrayHeader(4);
        let valuesArray = packedValues2.values;
        encode2(valuesArray);
        writeArrayHeader(0);
        writeArrayHeader(0);
        packedObjectMap = Object.create(sharedPackedObjectMap || null);
        for (let i = 0, l = valuesArray.length; i < l; i++) {
          packedObjectMap[valuesArray[i]] = i;
        }
      }
      if (sharedStructures) {
        targetView.setUint32(position2, 3655335424);
        position2 += 3;
        let definitions = sharedStructures.slice(0);
        definitions.unshift(57344);
        definitions.push(new Tag(sharedData.version, 1399353956));
        encode2(definitions);
      } else
        encode2(new Tag(sharedData.version, 1399353956));
    }
  }
];
function typedArrayEncoder(tag, size) {
  if (!isLittleEndianMachine2 && size > 1)
    tag -= 4;
  return {
    tag,
    encode: function writeExtBuffer(typedArray, encode2) {
      let length = typedArray.byteLength;
      let offset = typedArray.byteOffset || 0;
      let buffer = typedArray.buffer || typedArray;
      encode2(hasNodeBuffer ? Buffer2.from(buffer, offset, length) : new Uint8Array(buffer, offset, length));
    }
  };
}
function writeBuffer(buffer, makeRoom) {
  let length = buffer.byteLength;
  if (length < 24) {
    target[position2++] = 64 + length;
  } else if (length < 256) {
    target[position2++] = 88;
    target[position2++] = length;
  } else if (length < 65536) {
    target[position2++] = 89;
    target[position2++] = length >> 8;
    target[position2++] = length & 255;
  } else {
    target[position2++] = 90;
    targetView.setUint32(position2, length);
    position2 += 4;
  }
  if (position2 + length >= target.length) {
    makeRoom(position2 + length);
  }
  target.set(buffer.buffer ? buffer : new Uint8Array(buffer), position2);
  position2 += length;
}
function insertIds(serialized, idsToInsert) {
  let nextId;
  let distanceToMove = idsToInsert.length * 2;
  let lastEnd = serialized.length - distanceToMove;
  idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
  for (let id = 0; id < idsToInsert.length; id++) {
    let referee = idsToInsert[id];
    referee.id = id;
    for (let position3 of referee.references) {
      serialized[position3++] = id >> 8;
      serialized[position3] = id & 255;
    }
  }
  while (nextId = idsToInsert.pop()) {
    let offset = nextId.offset;
    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
    distanceToMove -= 2;
    let position3 = offset + distanceToMove;
    serialized[position3++] = 216;
    serialized[position3++] = 28;
    lastEnd = offset;
  }
  return serialized;
}
function writeBundles(start, encode2) {
  targetView.setUint32(bundledStrings2.position + start, position2 - bundledStrings2.position - start + 1);
  let writeStrings = bundledStrings2;
  bundledStrings2 = null;
  encode2(writeStrings[0]);
  encode2(writeStrings[1]);
}
var defaultEncoder = new Encoder({ useRecords: false });
var encode = defaultEncoder.encode;
var encodeAsIterable = defaultEncoder.encodeAsIterable;
var encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;
var { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;
var REUSE_BUFFER_MODE = 512;
var RESET_BUFFER_MODE = 1024;
var THROW_ON_ITERABLE = 2048;

// node_modules/@niivue/cbor-loader/node_modules/nifti-reader-js/dist/src/nifti-extension.js
var NIFTIEXTENSION = class {
  constructor(esize, ecode, edata, littleEndian) {
    __publicField(this, "esize");
    __publicField(this, "ecode");
    __publicField(this, "edata");
    __publicField(this, "littleEndian");
    if (esize % 16 != 0) {
      throw new Error("This does not appear to be a NIFTI extension");
    }
    this.esize = esize;
    this.ecode = ecode;
    this.edata = edata;
    this.littleEndian = littleEndian;
  }
  /**
   * Returns extension as ArrayBuffer.
   * @returns {ArrayBuffer}
   */
  toArrayBuffer() {
    let byteArray = new Uint8Array(this.esize);
    let data = new Uint8Array(this.edata);
    byteArray.set(data, 8);
    let view = new DataView(byteArray.buffer);
    view.setInt32(0, this.esize, this.littleEndian);
    view.setInt32(4, this.ecode, this.littleEndian);
    return byteArray.buffer;
  }
};

// node_modules/@niivue/cbor-loader/node_modules/nifti-reader-js/dist/src/utilities.js
var _Utils = class _Utils {
  /*** Static methods ***/
  static getStringAt(data, start, end) {
    var str = "", ctr, ch;
    for (ctr = start; ctr < end; ctr += 1) {
      ch = data.getUint8(ctr);
      if (ch !== 0) {
        str += String.fromCharCode(ch);
      }
    }
    return str;
  }
  static getIntAt(data, start, littleEndian) {
    return data.getInt32(start, littleEndian);
  }
  static getFloatAt(data, start, littleEndian) {
    return data.getFloat32(start, littleEndian);
  }
  static getDoubleAt(data, start, littleEndian) {
    return data.getFloat64(start, littleEndian);
  }
  static getInt64At(dataView2, index, littleEndian) {
    const low = dataView2.getUint32(index, littleEndian);
    const high = dataView2.getInt32(index + 4, littleEndian);
    let result;
    if (littleEndian) {
      result = high * 2 ** 32 + low;
    } else {
      result = low * 2 ** 32 + high;
    }
    if (high < 0) {
      result += -1 * 2 ** 32 * 2 ** 32;
    }
    return result;
  }
  static getExtensionsAt(data, start, littleEndian, voxOffset) {
    let extensions2 = [];
    let extensionByteIndex = start;
    while (extensionByteIndex < voxOffset) {
      let extensionLittleEndian = littleEndian;
      let esize = _Utils.getIntAt(data, extensionByteIndex, littleEndian);
      if (!esize) {
        break;
      }
      if (esize + extensionByteIndex > voxOffset) {
        extensionLittleEndian = !extensionLittleEndian;
        esize = _Utils.getIntAt(data, extensionByteIndex, extensionLittleEndian);
        if (esize + extensionByteIndex > voxOffset) {
          throw new Error("This does not appear to be a valid NIFTI extension");
        }
      }
      if (esize % 16 != 0) {
        throw new Error("This does not appear to be a NIFTI extension");
      }
      let ecode = _Utils.getIntAt(data, extensionByteIndex + 4, extensionLittleEndian);
      let edata = data.buffer.slice(extensionByteIndex + 8, extensionByteIndex + esize);
      let extension = new NIFTIEXTENSION(esize, ecode, edata, extensionLittleEndian);
      extensions2.push(extension);
      extensionByteIndex += esize;
    }
    return extensions2;
  }
  static toArrayBuffer(buffer) {
    var ab, view, i;
    ab = new ArrayBuffer(buffer.length);
    view = new Uint8Array(ab);
    for (i = 0; i < buffer.length; i += 1) {
      view[i] = buffer[i];
    }
    return ab;
  }
  static isString(obj) {
    return typeof obj === "string" || obj instanceof String;
  }
  static formatNumber(num, shortFormat = void 0) {
    let val;
    if (_Utils.isString(num)) {
      val = Number(num);
    } else {
      val = num;
    }
    if (shortFormat) {
      val = val.toPrecision(5);
    } else {
      val = val.toPrecision(7);
    }
    return parseFloat(val);
  }
  // http://stackoverflow.com/questions/18638900/javascript-crc32
  static makeCRCTable() {
    let c;
    let crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      crcTable[n] = c;
    }
    return crcTable;
  }
  static crc32(dataView2) {
    if (!_Utils.crcTable) {
      _Utils.crcTable = _Utils.makeCRCTable();
    }
    const crcTable = _Utils.crcTable;
    let crc = 0 ^ -1;
    for (var i = 0; i < dataView2.byteLength; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ dataView2.getUint8(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
};
/*** Static Pseudo-constants ***/
__publicField(_Utils, "crcTable", null);
__publicField(_Utils, "GUNZIP_MAGIC_COOKIE1", 31);
__publicField(_Utils, "GUNZIP_MAGIC_COOKIE2", 139);
__publicField(_Utils, "getByteAt", function(data, start) {
  return data.getUint8(start);
});
__publicField(_Utils, "getShortAt", function(data, start, littleEndian) {
  return data.getInt16(start, littleEndian);
});
var Utils = _Utils;

// node_modules/@niivue/cbor-loader/node_modules/nifti-reader-js/dist/src/nifti1.js
var _NIFTI1 = class _NIFTI1 {
  constructor() {
    __publicField(this, "littleEndian", false);
    __publicField(this, "dim_info", 0);
    __publicField(this, "dims", []);
    __publicField(this, "intent_p1", 0);
    __publicField(this, "intent_p2", 0);
    __publicField(this, "intent_p3", 0);
    __publicField(this, "intent_code", 0);
    __publicField(this, "datatypeCode", 0);
    __publicField(this, "numBitsPerVoxel", 0);
    __publicField(this, "slice_start", 0);
    __publicField(this, "slice_end", 0);
    __publicField(this, "slice_code", 0);
    __publicField(this, "pixDims", []);
    __publicField(this, "vox_offset", 0);
    __publicField(this, "scl_slope", 1);
    __publicField(this, "scl_inter", 0);
    __publicField(this, "xyzt_units", 0);
    __publicField(this, "cal_max", 0);
    __publicField(this, "cal_min", 0);
    __publicField(this, "slice_duration", 0);
    __publicField(this, "toffset", 0);
    __publicField(this, "description", "");
    __publicField(this, "aux_file", "");
    __publicField(this, "intent_name", "");
    __publicField(this, "qform_code", 0);
    __publicField(this, "sform_code", 0);
    __publicField(this, "quatern_a", 0);
    __publicField(this, "quatern_b", 0);
    __publicField(this, "quatern_c", 0);
    __publicField(this, "quatern_d", 0);
    __publicField(this, "qoffset_x", 0);
    __publicField(this, "qoffset_y", 0);
    __publicField(this, "qoffset_z", 0);
    __publicField(this, "affine", [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ]);
    __publicField(this, "qfac", 1);
    __publicField(this, "quatern_R");
    __publicField(this, "magic", "0");
    __publicField(this, "isHDR", false);
    __publicField(this, "extensionFlag", [0, 0, 0, 0]);
    __publicField(this, "extensionSize", 0);
    __publicField(this, "extensionCode", 0);
    __publicField(this, "extensions", []);
    /**
     * Returns a human-readable string of datatype.
     * @param {number} code
     * @returns {string}
     */
    __publicField(this, "getDatatypeCodeString", function(code) {
      if (code === _NIFTI1.TYPE_UINT8) {
        return "1-Byte Unsigned Integer";
      } else if (code === _NIFTI1.TYPE_INT16) {
        return "2-Byte Signed Integer";
      } else if (code === _NIFTI1.TYPE_INT32) {
        return "4-Byte Signed Integer";
      } else if (code === _NIFTI1.TYPE_FLOAT32) {
        return "4-Byte Float";
      } else if (code === _NIFTI1.TYPE_FLOAT64) {
        return "8-Byte Float";
      } else if (code === _NIFTI1.TYPE_RGB24) {
        return "RGB";
      } else if (code === _NIFTI1.TYPE_INT8) {
        return "1-Byte Signed Integer";
      } else if (code === _NIFTI1.TYPE_UINT16) {
        return "2-Byte Unsigned Integer";
      } else if (code === _NIFTI1.TYPE_UINT32) {
        return "4-Byte Unsigned Integer";
      } else if (code === _NIFTI1.TYPE_INT64) {
        return "8-Byte Signed Integer";
      } else if (code === _NIFTI1.TYPE_UINT64) {
        return "8-Byte Unsigned Integer";
      } else {
        return "Unknown";
      }
    });
    /**
     * Returns a human-readable string of transform type.
     * @param {number} code
     * @returns {string}
     */
    __publicField(this, "getTransformCodeString", function(code) {
      if (code === _NIFTI1.XFORM_SCANNER_ANAT) {
        return "Scanner";
      } else if (code === _NIFTI1.XFORM_ALIGNED_ANAT) {
        return "Aligned";
      } else if (code === _NIFTI1.XFORM_TALAIRACH) {
        return "Talairach";
      } else if (code === _NIFTI1.XFORM_MNI_152) {
        return "MNI";
      } else {
        return "Unknown";
      }
    });
    /**
     * Returns a human-readable string of spatial and temporal units.
     * @param {number} code
     * @returns {string}
     */
    __publicField(this, "getUnitsCodeString", function(code) {
      if (code === _NIFTI1.UNITS_METER) {
        return "Meters";
      } else if (code === _NIFTI1.UNITS_MM) {
        return "Millimeters";
      } else if (code === _NIFTI1.UNITS_MICRON) {
        return "Microns";
      } else if (code === _NIFTI1.UNITS_SEC) {
        return "Seconds";
      } else if (code === _NIFTI1.UNITS_MSEC) {
        return "Milliseconds";
      } else if (code === _NIFTI1.UNITS_USEC) {
        return "Microseconds";
      } else if (code === _NIFTI1.UNITS_HZ) {
        return "Hz";
      } else if (code === _NIFTI1.UNITS_PPM) {
        return "PPM";
      } else if (code === _NIFTI1.UNITS_RADS) {
        return "Rads";
      } else {
        return "Unknown";
      }
    });
    __publicField(this, "nifti_mat33_mul", function(A, B) {
      var C = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
      ], i, j;
      for (i = 0; i < 3; i += 1) {
        for (j = 0; j < 3; j += 1) {
          C[i][j] = A[i][0] * B[0][j] + A[i][1] * B[1][j] + A[i][2] * B[2][j];
        }
      }
      return C;
    });
    __publicField(this, "nifti_mat33_determ", function(R) {
      var r11, r12, r13, r21, r22, r23, r31, r32, r33;
      r11 = R[0][0];
      r12 = R[0][1];
      r13 = R[0][2];
      r21 = R[1][0];
      r22 = R[1][1];
      r23 = R[1][2];
      r31 = R[2][0];
      r32 = R[2][1];
      r33 = R[2][2];
      return r11 * r22 * r33 - r11 * r32 * r23 - r21 * r12 * r33 + r21 * r32 * r13 + r31 * r12 * r23 - r31 * r22 * r13;
    });
  }
  /*** Prototype Methods ***/
  /**
   * Reads the header data.
   * @param {ArrayBuffer} data
   */
  readHeader(data) {
    var rawData = new DataView(data), magicCookieVal = Utils.getIntAt(rawData, 0, this.littleEndian), ctr, ctrOut, ctrIn, index;
    if (magicCookieVal !== _NIFTI1.MAGIC_COOKIE) {
      this.littleEndian = true;
      magicCookieVal = Utils.getIntAt(rawData, 0, this.littleEndian);
    }
    if (magicCookieVal !== _NIFTI1.MAGIC_COOKIE) {
      throw new Error("This does not appear to be a NIFTI file!");
    }
    this.dim_info = Utils.getByteAt(rawData, 39);
    for (ctr = 0; ctr < 8; ctr += 1) {
      index = 40 + ctr * 2;
      this.dims[ctr] = Utils.getShortAt(rawData, index, this.littleEndian);
    }
    this.intent_p1 = Utils.getFloatAt(rawData, 56, this.littleEndian);
    this.intent_p2 = Utils.getFloatAt(rawData, 60, this.littleEndian);
    this.intent_p3 = Utils.getFloatAt(rawData, 64, this.littleEndian);
    this.intent_code = Utils.getShortAt(rawData, 68, this.littleEndian);
    this.datatypeCode = Utils.getShortAt(rawData, 70, this.littleEndian);
    this.numBitsPerVoxel = Utils.getShortAt(rawData, 72, this.littleEndian);
    this.slice_start = Utils.getShortAt(rawData, 74, this.littleEndian);
    for (ctr = 0; ctr < 8; ctr += 1) {
      index = 76 + ctr * 4;
      this.pixDims[ctr] = Utils.getFloatAt(rawData, index, this.littleEndian);
    }
    this.vox_offset = Utils.getFloatAt(rawData, 108, this.littleEndian);
    this.scl_slope = Utils.getFloatAt(rawData, 112, this.littleEndian);
    this.scl_inter = Utils.getFloatAt(rawData, 116, this.littleEndian);
    this.slice_end = Utils.getShortAt(rawData, 120, this.littleEndian);
    this.slice_code = Utils.getByteAt(rawData, 122);
    this.xyzt_units = Utils.getByteAt(rawData, 123);
    this.cal_max = Utils.getFloatAt(rawData, 124, this.littleEndian);
    this.cal_min = Utils.getFloatAt(rawData, 128, this.littleEndian);
    this.slice_duration = Utils.getFloatAt(rawData, 132, this.littleEndian);
    this.toffset = Utils.getFloatAt(rawData, 136, this.littleEndian);
    this.description = Utils.getStringAt(rawData, 148, 228);
    this.aux_file = Utils.getStringAt(rawData, 228, 252);
    this.qform_code = Utils.getShortAt(rawData, 252, this.littleEndian);
    this.sform_code = Utils.getShortAt(rawData, 254, this.littleEndian);
    this.quatern_b = Utils.getFloatAt(rawData, 256, this.littleEndian);
    this.quatern_c = Utils.getFloatAt(rawData, 260, this.littleEndian);
    this.quatern_d = Utils.getFloatAt(rawData, 264, this.littleEndian);
    this.quatern_a = Math.sqrt(1 - (Math.pow(this.quatern_b, 2) + Math.pow(this.quatern_c, 2) + Math.pow(this.quatern_d, 2)));
    this.qoffset_x = Utils.getFloatAt(rawData, 268, this.littleEndian);
    this.qoffset_y = Utils.getFloatAt(rawData, 272, this.littleEndian);
    this.qoffset_z = Utils.getFloatAt(rawData, 276, this.littleEndian);
    if (this.qform_code < 1 && this.sform_code < 1) {
      this.affine[0][0] = this.pixDims[1];
      this.affine[1][1] = this.pixDims[2];
      this.affine[2][2] = this.pixDims[3];
    }
    if (this.qform_code > 0 && this.sform_code < this.qform_code) {
      const a = this.quatern_a;
      const b = this.quatern_b;
      const c = this.quatern_c;
      const d = this.quatern_d;
      this.qfac = this.pixDims[0] === 0 ? 1 : this.pixDims[0];
      this.quatern_R = [
        [
          a * a + b * b - c * c - d * d,
          2 * b * c - 2 * a * d,
          2 * b * d + 2 * a * c
        ],
        [
          2 * b * c + 2 * a * d,
          a * a + c * c - b * b - d * d,
          2 * c * d - 2 * a * b
        ],
        [
          2 * b * d - 2 * a * c,
          2 * c * d + 2 * a * b,
          a * a + d * d - c * c - b * b
        ]
      ];
      for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 3; ctrIn += 1) {
          this.affine[ctrOut][ctrIn] = this.quatern_R[ctrOut][ctrIn] * this.pixDims[ctrIn + 1];
          if (ctrIn === 2) {
            this.affine[ctrOut][ctrIn] *= this.qfac;
          }
        }
      }
      this.affine[0][3] = this.qoffset_x;
      this.affine[1][3] = this.qoffset_y;
      this.affine[2][3] = this.qoffset_z;
    } else if (this.sform_code > 0) {
      for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
          index = 280 + (ctrOut * 4 + ctrIn) * 4;
          this.affine[ctrOut][ctrIn] = Utils.getFloatAt(rawData, index, this.littleEndian);
        }
      }
    }
    this.affine[3][0] = 0;
    this.affine[3][1] = 0;
    this.affine[3][2] = 0;
    this.affine[3][3] = 1;
    this.intent_name = Utils.getStringAt(rawData, 328, 344);
    this.magic = Utils.getStringAt(rawData, 344, 348);
    this.isHDR = this.magic === String.fromCharCode.apply(null, _NIFTI1.MAGIC_NUMBER2);
    if (rawData.byteLength > _NIFTI1.MAGIC_COOKIE) {
      this.extensionFlag[0] = Utils.getByteAt(rawData, 348);
      this.extensionFlag[1] = Utils.getByteAt(rawData, 348 + 1);
      this.extensionFlag[2] = Utils.getByteAt(rawData, 348 + 2);
      this.extensionFlag[3] = Utils.getByteAt(rawData, 348 + 3);
      let isExtensionCapable = true;
      if (!this.isHDR && this.vox_offset <= 352)
        isExtensionCapable = false;
      if (rawData.byteLength <= 352 + 16)
        isExtensionCapable = false;
      if (isExtensionCapable && this.extensionFlag[0]) {
        this.extensions = Utils.getExtensionsAt(rawData, this.getExtensionLocation(), this.littleEndian, this.vox_offset);
        this.extensionSize = this.extensions[0].esize;
        this.extensionCode = this.extensions[0].ecode;
      }
    }
  }
  /**
   * Returns a formatted string of header fields.
   * @returns {string}
   */
  toFormattedString() {
    var fmt = Utils.formatNumber, string = "";
    string += "Dim Info = " + this.dim_info + "\n";
    string += "Image Dimensions (1-8): " + this.dims[0] + ", " + this.dims[1] + ", " + this.dims[2] + ", " + this.dims[3] + ", " + this.dims[4] + ", " + this.dims[5] + ", " + this.dims[6] + ", " + this.dims[7] + "\n";
    string += "Intent Parameters (1-3): " + this.intent_p1 + ", " + this.intent_p2 + ", " + this.intent_p3 + "\n";
    string += "Intent Code = " + this.intent_code + "\n";
    string += "Datatype = " + this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n";
    string += "Bits Per Voxel = " + this.numBitsPerVoxel + "\n";
    string += "Slice Start = " + this.slice_start + "\n";
    string += "Voxel Dimensions (1-8): " + fmt(this.pixDims[0]) + ", " + fmt(this.pixDims[1]) + ", " + fmt(this.pixDims[2]) + ", " + fmt(this.pixDims[3]) + ", " + fmt(this.pixDims[4]) + ", " + fmt(this.pixDims[5]) + ", " + fmt(this.pixDims[6]) + ", " + fmt(this.pixDims[7]) + "\n";
    string += "Image Offset = " + this.vox_offset + "\n";
    string += "Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n";
    string += "Slice End = " + this.slice_end + "\n";
    string += "Slice Code = " + this.slice_code + "\n";
    string += "Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(_NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(_NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n";
    string += "Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n";
    string += "Slice Duration = " + this.slice_duration + "\n";
    string += "Time Axis Shift = " + this.toffset + "\n";
    string += 'Description: "' + this.description + '"\n';
    string += 'Auxiliary File: "' + this.aux_file + '"\n';
    string += "Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n";
    string += "S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n";
    string += "Quaternion Parameters:  b = " + fmt(this.quatern_b) + "  c = " + fmt(this.quatern_c) + "  d = " + fmt(this.quatern_d) + "\n";
    string += "Quaternion Offsets:  x = " + this.qoffset_x + "  y = " + this.qoffset_y + "  z = " + this.qoffset_z + "\n";
    string += "S-Form Parameters X: " + fmt(this.affine[0][0]) + ", " + fmt(this.affine[0][1]) + ", " + fmt(this.affine[0][2]) + ", " + fmt(this.affine[0][3]) + "\n";
    string += "S-Form Parameters Y: " + fmt(this.affine[1][0]) + ", " + fmt(this.affine[1][1]) + ", " + fmt(this.affine[1][2]) + ", " + fmt(this.affine[1][3]) + "\n";
    string += "S-Form Parameters Z: " + fmt(this.affine[2][0]) + ", " + fmt(this.affine[2][1]) + ", " + fmt(this.affine[2][2]) + ", " + fmt(this.affine[2][3]) + "\n";
    string += 'Intent Name: "' + this.intent_name + '"\n';
    if (this.extensionFlag[0]) {
      string += "Extension: Size = " + this.extensionSize + "  Code = " + this.extensionCode + "\n";
    }
    return string;
  }
  /**
   * Returns the qform matrix.
   * @returns {Array.<Array.<number>>}
   */
  getQformMat() {
    return this.convertNiftiQFormToNiftiSForm(this.quatern_b, this.quatern_c, this.quatern_d, this.qoffset_x, this.qoffset_y, this.qoffset_z, this.pixDims[1], this.pixDims[2], this.pixDims[3], this.pixDims[0]);
  }
  /**
   * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
   * @param {number} qb
   * @param {number} qc
   * @param {number} qd
   * @param {number} qx
   * @param {number} qy
   * @param {number} qz
   * @param {number} dx
   * @param {number} dy
   * @param {number} dz
   * @param {number} qfac
   * @returns {Array.<Array.<number>>}
   */
  convertNiftiQFormToNiftiSForm(qb, qc, qd, qx, qy, qz, dx, dy, dz, qfac) {
    var R = [
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ], a, b = qb, c = qc, d = qd, xd, yd, zd;
    R[3][0] = R[3][1] = R[3][2] = 0;
    R[3][3] = 1;
    a = 1 - (b * b + c * c + d * d);
    if (a < 1e-7) {
      a = 1 / Math.sqrt(b * b + c * c + d * d);
      b *= a;
      c *= a;
      d *= a;
      a = 0;
    } else {
      a = Math.sqrt(a);
    }
    xd = dx > 0 ? dx : 1;
    yd = dy > 0 ? dy : 1;
    zd = dz > 0 ? dz : 1;
    if (qfac < 0) {
      zd = -zd;
    }
    R[0][0] = (a * a + b * b - c * c - d * d) * xd;
    R[0][1] = 2 * (b * c - a * d) * yd;
    R[0][2] = 2 * (b * d + a * c) * zd;
    R[1][0] = 2 * (b * c + a * d) * xd;
    R[1][1] = (a * a + c * c - b * b - d * d) * yd;
    R[1][2] = 2 * (c * d - a * b) * zd;
    R[2][0] = 2 * (b * d - a * c) * xd;
    R[2][1] = 2 * (c * d + a * b) * yd;
    R[2][2] = (a * a + d * d - c * c - b * b) * zd;
    R[0][3] = qx;
    R[1][3] = qy;
    R[2][3] = qz;
    return R;
  }
  /**
   * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
   * @param {Array.<Array.<number>>} R
   * @returns {string}
   */
  convertNiftiSFormToNEMA(R) {
    var xi, xj, xk, yi, yj, yk, zi, zj, zk, val, detQ, detP, i, j, k, p, q, r, ibest, jbest, kbest, pbest, qbest, rbest, M, vbest, Q, P, iChar, jChar, kChar, iSense, jSense, kSense;
    k = 0;
    Q = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0]
    ];
    P = [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0]
    ];
    xi = R[0][0];
    xj = R[0][1];
    xk = R[0][2];
    yi = R[1][0];
    yj = R[1][1];
    yk = R[1][2];
    zi = R[2][0];
    zj = R[2][1];
    zk = R[2][2];
    val = Math.sqrt(xi * xi + yi * yi + zi * zi);
    if (val === 0) {
      return null;
    }
    xi /= val;
    yi /= val;
    zi /= val;
    val = Math.sqrt(xj * xj + yj * yj + zj * zj);
    if (val === 0) {
      return null;
    }
    xj /= val;
    yj /= val;
    zj /= val;
    val = xi * xj + yi * yj + zi * zj;
    if (Math.abs(val) > 1e-4) {
      xj -= val * xi;
      yj -= val * yi;
      zj -= val * zi;
      val = Math.sqrt(xj * xj + yj * yj + zj * zj);
      if (val === 0) {
        return null;
      }
      xj /= val;
      yj /= val;
      zj /= val;
    }
    val = Math.sqrt(xk * xk + yk * yk + zk * zk);
    if (val === 0) {
      xk = yi * zj - zi * yj;
      yk = zi * xj - zj * xi;
      zk = xi * yj - yi * xj;
    } else {
      xk /= val;
      yk /= val;
      zk /= val;
    }
    val = xi * xk + yi * yk + zi * zk;
    if (Math.abs(val) > 1e-4) {
      xk -= val * xi;
      yk -= val * yi;
      zk -= val * zi;
      val = Math.sqrt(xk * xk + yk * yk + zk * zk);
      if (val === 0) {
        return null;
      }
      xk /= val;
      yk /= val;
      zk /= val;
    }
    val = xj * xk + yj * yk + zj * zk;
    if (Math.abs(val) > 1e-4) {
      xk -= val * xj;
      yk -= val * yj;
      zk -= val * zj;
      val = Math.sqrt(xk * xk + yk * yk + zk * zk);
      if (val === 0) {
        return null;
      }
      xk /= val;
      yk /= val;
      zk /= val;
    }
    Q[0][0] = xi;
    Q[0][1] = xj;
    Q[0][2] = xk;
    Q[1][0] = yi;
    Q[1][1] = yj;
    Q[1][2] = yk;
    Q[2][0] = zi;
    Q[2][1] = zj;
    Q[2][2] = zk;
    detQ = this.nifti_mat33_determ(Q);
    if (detQ === 0) {
      return null;
    }
    vbest = -666;
    ibest = pbest = qbest = rbest = 1;
    jbest = 2;
    kbest = 3;
    for (i = 1; i <= 3; i += 1) {
      for (j = 1; j <= 3; j += 1) {
        if (i !== j) {
          for (k = 1; k <= 3; k += 1) {
            if (!(i === k || j === k)) {
              P[0][0] = P[0][1] = P[0][2] = P[1][0] = P[1][1] = P[1][2] = P[2][0] = P[2][1] = P[2][2] = 0;
              for (p = -1; p <= 1; p += 2) {
                for (q = -1; q <= 1; q += 2) {
                  for (r = -1; r <= 1; r += 2) {
                    P[0][i - 1] = p;
                    P[1][j - 1] = q;
                    P[2][k - 1] = r;
                    detP = this.nifti_mat33_determ(P);
                    if (detP * detQ > 0) {
                      M = this.nifti_mat33_mul(P, Q);
                      val = M[0][0] + M[1][1] + M[2][2];
                      if (val > vbest) {
                        vbest = val;
                        ibest = i;
                        jbest = j;
                        kbest = k;
                        pbest = p;
                        qbest = q;
                        rbest = r;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    iChar = jChar = kChar = iSense = jSense = kSense = "";
    switch (ibest * pbest) {
      case 1:
        iChar = "X";
        iSense = "+";
        break;
      case -1:
        iChar = "X";
        iSense = "-";
        break;
      case 2:
        iChar = "Y";
        iSense = "+";
        break;
      case -2:
        iChar = "Y";
        iSense = "-";
        break;
      case 3:
        iChar = "Z";
        iSense = "+";
        break;
      case -3:
        iChar = "Z";
        iSense = "-";
        break;
    }
    switch (jbest * qbest) {
      case 1:
        jChar = "X";
        jSense = "+";
        break;
      case -1:
        jChar = "X";
        jSense = "-";
        break;
      case 2:
        jChar = "Y";
        jSense = "+";
        break;
      case -2:
        jChar = "Y";
        jSense = "-";
        break;
      case 3:
        jChar = "Z";
        jSense = "+";
        break;
      case -3:
        jChar = "Z";
        jSense = "-";
        break;
    }
    switch (kbest * rbest) {
      case 1:
        kChar = "X";
        kSense = "+";
        break;
      case -1:
        kChar = "X";
        kSense = "-";
        break;
      case 2:
        kChar = "Y";
        kSense = "+";
        break;
      case -2:
        kChar = "Y";
        kSense = "-";
        break;
      case 3:
        kChar = "Z";
        kSense = "+";
        break;
      case -3:
        kChar = "Z";
        kSense = "-";
        break;
    }
    return iChar + jChar + kChar + iSense + jSense + kSense;
  }
  /**
   * Returns the byte index of the extension.
   * @returns {number}
   */
  getExtensionLocation() {
    return _NIFTI1.MAGIC_COOKIE + 4;
  }
  /**
   * Returns the extension size.
   * @param {DataView} data
   * @returns {number}
   */
  getExtensionSize(data) {
    return Utils.getIntAt(data, this.getExtensionLocation(), this.littleEndian);
  }
  /**
   * Returns the extension code.
   * @param {DataView} data
   * @returns {number}
   */
  getExtensionCode(data) {
    return Utils.getIntAt(data, this.getExtensionLocation() + 4, this.littleEndian);
  }
  /**
   * Adds an extension
   * @param {NIFTIEXTENSION} extension
   * @param {number} index
   */
  addExtension(extension, index = -1) {
    if (index == -1) {
      this.extensions.push(extension);
    } else {
      this.extensions.splice(index, 0, extension);
    }
    this.vox_offset += extension.esize;
  }
  /**
   * Removes an extension
   * @param {number} index
   */
  removeExtension(index) {
    let extension = this.extensions[index];
    if (extension) {
      this.vox_offset -= extension.esize;
    }
    this.extensions.splice(index, 1);
  }
  /**
   * Returns header as ArrayBuffer.
   * @param {boolean} includeExtensions - should extension bytes be included
   * @returns {ArrayBuffer}
   */
  toArrayBuffer(includeExtensions = false) {
    const SHORT_SIZE = 2;
    const FLOAT32_SIZE = 4;
    let byteSize = 348 + 4;
    if (includeExtensions) {
      for (let extension of this.extensions) {
        byteSize += extension.esize;
      }
    }
    let byteArray = new Uint8Array(byteSize);
    let view = new DataView(byteArray.buffer);
    view.setInt32(0, 348, this.littleEndian);
    view.setUint8(39, this.dim_info);
    for (let i = 0; i < 8; i++) {
      view.setUint16(40 + SHORT_SIZE * i, this.dims[i], this.littleEndian);
    }
    view.setFloat32(56, this.intent_p1, this.littleEndian);
    view.setFloat32(60, this.intent_p2, this.littleEndian);
    view.setFloat32(64, this.intent_p3, this.littleEndian);
    view.setInt16(68, this.intent_code, this.littleEndian);
    view.setInt16(70, this.datatypeCode, this.littleEndian);
    view.setInt16(72, this.numBitsPerVoxel, this.littleEndian);
    view.setInt16(74, this.slice_start, this.littleEndian);
    for (let i = 0; i < 8; i++) {
      view.setFloat32(76 + FLOAT32_SIZE * i, this.pixDims[i], this.littleEndian);
    }
    view.setFloat32(108, this.vox_offset, this.littleEndian);
    view.setFloat32(112, this.scl_slope, this.littleEndian);
    view.setFloat32(116, this.scl_inter, this.littleEndian);
    view.setInt16(120, this.slice_end, this.littleEndian);
    view.setUint8(122, this.slice_code);
    view.setUint8(123, this.xyzt_units);
    view.setFloat32(124, this.cal_max, this.littleEndian);
    view.setFloat32(128, this.cal_min, this.littleEndian);
    view.setFloat32(132, this.slice_duration, this.littleEndian);
    view.setFloat32(136, this.toffset, this.littleEndian);
    byteArray.set(new TextEncoder().encode(this.description), 148);
    byteArray.set(new TextEncoder().encode(this.aux_file), 228);
    view.setInt16(252, this.qform_code, this.littleEndian);
    view.setInt16(254, this.sform_code, this.littleEndian);
    view.setFloat32(256, this.quatern_b, this.littleEndian);
    view.setFloat32(260, this.quatern_c, this.littleEndian);
    view.setFloat32(264, this.quatern_d, this.littleEndian);
    view.setFloat32(268, this.qoffset_x, this.littleEndian);
    view.setFloat32(272, this.qoffset_y, this.littleEndian);
    view.setFloat32(276, this.qoffset_z, this.littleEndian);
    const flattened = this.affine.flat();
    for (let i = 0; i < 12; i++) {
      view.setFloat32(280 + FLOAT32_SIZE * i, flattened[i], this.littleEndian);
    }
    byteArray.set(new TextEncoder().encode(this.intent_name), 328);
    byteArray.set(new TextEncoder().encode(this.magic), 344);
    if (includeExtensions) {
      byteArray.set(Uint8Array.from([1, 0, 0, 0]), 348);
      let extensionByteIndex = this.getExtensionLocation();
      for (const extension of this.extensions) {
        view.setInt32(extensionByteIndex, extension.esize, extension.littleEndian);
        view.setInt32(extensionByteIndex + 4, extension.ecode, extension.littleEndian);
        byteArray.set(new Uint8Array(extension.edata), extensionByteIndex + 8);
        extensionByteIndex += extension.esize;
      }
    } else {
      byteArray.set(new Uint8Array(4).fill(0), 348);
    }
    return byteArray.buffer;
  }
};
/*** Static Pseudo-constants ***/
// datatype codes
__publicField(_NIFTI1, "TYPE_NONE", 0);
__publicField(_NIFTI1, "TYPE_BINARY", 1);
__publicField(_NIFTI1, "TYPE_UINT8", 2);
__publicField(_NIFTI1, "TYPE_INT16", 4);
__publicField(_NIFTI1, "TYPE_INT32", 8);
__publicField(_NIFTI1, "TYPE_FLOAT32", 16);
__publicField(_NIFTI1, "TYPE_COMPLEX64", 32);
__publicField(_NIFTI1, "TYPE_FLOAT64", 64);
__publicField(_NIFTI1, "TYPE_RGB24", 128);
__publicField(_NIFTI1, "TYPE_INT8", 256);
__publicField(_NIFTI1, "TYPE_UINT16", 512);
__publicField(_NIFTI1, "TYPE_UINT32", 768);
__publicField(_NIFTI1, "TYPE_INT64", 1024);
__publicField(_NIFTI1, "TYPE_UINT64", 1280);
__publicField(_NIFTI1, "TYPE_FLOAT128", 1536);
__publicField(_NIFTI1, "TYPE_COMPLEX128", 1792);
__publicField(_NIFTI1, "TYPE_COMPLEX256", 2048);
// transform codes
__publicField(_NIFTI1, "XFORM_UNKNOWN", 0);
__publicField(_NIFTI1, "XFORM_SCANNER_ANAT", 1);
__publicField(_NIFTI1, "XFORM_ALIGNED_ANAT", 2);
__publicField(_NIFTI1, "XFORM_TALAIRACH", 3);
__publicField(_NIFTI1, "XFORM_MNI_152", 4);
// unit codes
__publicField(_NIFTI1, "SPATIAL_UNITS_MASK", 7);
__publicField(_NIFTI1, "TEMPORAL_UNITS_MASK", 56);
__publicField(_NIFTI1, "UNITS_UNKNOWN", 0);
__publicField(_NIFTI1, "UNITS_METER", 1);
__publicField(_NIFTI1, "UNITS_MM", 2);
__publicField(_NIFTI1, "UNITS_MICRON", 3);
__publicField(_NIFTI1, "UNITS_SEC", 8);
__publicField(_NIFTI1, "UNITS_MSEC", 16);
__publicField(_NIFTI1, "UNITS_USEC", 24);
__publicField(_NIFTI1, "UNITS_HZ", 32);
__publicField(_NIFTI1, "UNITS_PPM", 40);
__publicField(_NIFTI1, "UNITS_RADS", 48);
// nifti1 codes
__publicField(_NIFTI1, "MAGIC_COOKIE", 348);
__publicField(_NIFTI1, "STANDARD_HEADER_SIZE", 348);
__publicField(_NIFTI1, "MAGIC_NUMBER_LOCATION", 344);
__publicField(_NIFTI1, "MAGIC_NUMBER", [110, 43, 49]);
// n+1 (.nii)
__publicField(_NIFTI1, "MAGIC_NUMBER2", [110, 105, 49]);
// ni1 (.hdr/.img)
__publicField(_NIFTI1, "EXTENSION_HEADER_SIZE", 8);
var NIFTI1 = _NIFTI1;

// node_modules/@niivue/cbor-loader/src/loader.js
function iwm2meshCore(iwm) {
  if (!Object.prototype.hasOwnProperty.call(iwm, "meshType") || !Object.prototype.hasOwnProperty.call(iwm, "cells") || !Object.prototype.hasOwnProperty.call(iwm, "points")) {
    throw new Error('.iwm.cbor must have "meshType", "cells" and "points".');
  }
  let cells;
  if (iwm.cells instanceof BigUint64Array || iwm.cells instanceof BigInt64Array) {
    cells = new Uint32Array(iwm.cells.length);
    for (let i2 = 0; i2 < iwm.cells.length; i2++) {
      cells[i2] = Number(BigInt(iwm.cells[i2]) & BigInt(4294967295));
    }
  } else if (iwm.cells[0] instanceof Uint32Array || typeof iwm.cells[0] === "number") {
    cells = new Uint32Array(iwm.cells);
  } else {
    throw new Error("Unsupported data type in iwm.cells");
  }
  let ntri = 0;
  let i = 0;
  while (i < cells.length) {
    const cellType = cells[i];
    const cellNum = cells[i + 1];
    if (cellType < 2 || cellType < 2 || cellNum < 3) {
      throw new Error(`unsupported iwm cell type ${cellType} or cellNum ${cellNum}`);
    }
    i += cellNum + 2;
    ntri += cellNum - 2;
  }
  const indices = new Uint32Array(ntri * 3);
  i = 0;
  let j = 0;
  while (i < cells.length) {
    const cellNum = cells[i + 1];
    const newTri = cellNum - 2;
    for (let t = 0; t < newTri; t++) {
      indices[j++] = cells[i + 2];
      indices[j++] = cells[i + 2 + 1 + t];
      indices[j++] = cells[i + 2 + 2 + t];
    }
    i += cellNum + 2;
  }
  const positions = new Float32Array(iwm.points);
  i = 0;
  while (i < positions.length) {
    positions[i] = -positions[i];
    positions[i + 1] = -positions[i + 1];
    i += 3;
  }
  return {
    positions,
    indices
  };
}
function iwm2mesh(arrayBuffer) {
  const iwm = decode(new Uint8Array(arrayBuffer));
  return iwm2meshCore(iwm);
}
function mesh2iwm(pts, tris, isEncodeCBOR = true) {
  const iwm = {
    meshType: {
      dimension: 3,
      pointComponentType: "float32",
      pointPixelComponentType: "int8",
      pointPixelType: "Scalar",
      pointPixelComponents: 0,
      cellComponentType: "uint64",
      cellPixelComponentType: "int8",
      cellPixelType: "Scalar",
      cellPixelComponents: 0
    },
    numberOfPointPixels: 0n,
    numberOfCellPixels: 0n
  };
  const ntri = Math.floor(tris.length / 3);
  const cellBufferSize = ntri * 5;
  iwm.cells = new BigUint64Array(cellBufferSize);
  let j = 0;
  let k = 0;
  for (let t = 0; t < ntri; t++) {
    iwm.cells[j++] = 2n;
    iwm.cells[j++] = 3n;
    iwm.cells[j++] = BigInt(tris[k++]);
    iwm.cells[j++] = BigInt(tris[k++]);
    iwm.cells[j++] = BigInt(tris[k++]);
  }
  iwm.cellBufferSize = BigInt(cellBufferSize);
  iwm.numberOfCells = BigInt(ntri);
  iwm.points = pts.slice();
  let i = 0;
  while (i < iwm.points.length) {
    iwm.points[i] = -iwm.points[i];
    iwm.points[i + 1] = -iwm.points[i + 1];
    i += 3;
  }
  iwm.numberOfPoints = BigInt(Math.floor(pts.length) / 3);
  if (isEncodeCBOR) {
    return encode(iwm);
  }
  return iwm;
}
function iwi2niiCore(iwi) {
  if (!Object.prototype.hasOwnProperty.call(iwi, "imageType") || !Object.prototype.hasOwnProperty.call(iwi, "size") || !Object.prototype.hasOwnProperty.call(iwi, "data")) {
    throw new Error('.iwi.cbor must have "imageType", "size" and "data".');
  }
  const hdr = new NIFTI1();
  hdr.littleEndian = true;
  hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
  hdr.dims[0] = iwi.size.length;
  let nvox = 1;
  for (let i = 0; i < iwi.size.length; i++) {
    hdr.dims[i + 1] = Number(BigInt(iwi.size[i]) & BigInt(4294967295));
    nvox *= Math.max(hdr.dims[i + 1], 1);
  }
  hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
  if (Object.prototype.hasOwnProperty.call(iwi, "spacing")) {
    for (let i = 0; i < iwi.spacing.length; i++) {
      hdr.pixDims[i + 1] = iwi.spacing[i];
    }
  }
  if (iwi.data instanceof Uint8Array) {
    if (Object.prototype.hasOwnProperty.call(iwi.imageType, "pixelType") && iwi.imageType.pixelType === "RGB") {
      hdr.numBitsPerVoxel = 24;
      hdr.datatypeCode = 128;
    } else {
      hdr.numBitsPerVoxel = 8;
      hdr.datatypeCode = 2;
    }
  } else if (iwi.data instanceof Int16Array) {
    hdr.numBitsPerVoxel = 16;
    hdr.datatypeCode = 4;
  } else if (iwi.data instanceof Uint16Array) {
    hdr.numBitsPerVoxel = 16;
    hdr.datatypeCode = 512;
  } else if (iwi.data instanceof Int32Array) {
    hdr.numBitsPerVoxel = 32;
    hdr.datatypeCode = 8;
  } else if (iwi.data instanceof Float64Array) {
    hdr.numBitsPerVoxel = 64;
    hdr.datatypeCode = 64;
  } else if (iwi.data instanceof Float32Array) {
    hdr.numBitsPerVoxel = 32;
    hdr.datatypeCode = 16;
  } else {
    throw new Error(".iwi.cbor voxels use unsupported datatype.");
  }
  const nbyte = nvox * Math.floor(hdr.numBitsPerVoxel / 8);
  const img8 = new Uint8Array(iwi.data.buffer, iwi.data.byteOffset, iwi.data.byteLength);
  if (nbyte !== img8.byteLength) {
    throw new Error(`expected ${nbyte} bytes but have ${img8.byteLength}`);
  }
  hdr.vox_offset = 352;
  hdr.scl_inter = 0;
  hdr.scl_slope = 1;
  hdr.magic = "n+1";
  if (Object.prototype.hasOwnProperty.call(iwi, "direction") && Object.prototype.hasOwnProperty.call(iwi, "origin")) {
    const m = iwi.direction.slice();
    const mm = iwi.spacing.slice();
    const o = iwi.origin;
    hdr.sform_code = 1;
    hdr.affine = [
      [m[0] * -mm[0], m[3] * -mm[1], m[6] * -mm[2], -o[0]],
      [m[1] * -mm[0], m[4] * -mm[1], m[7] * -mm[2], -o[1]],
      [m[2] * mm[0], m[5] * mm[1], m[8] * mm[2], o[2]],
      [0, 0, 0, 1]
    ];
  }
  const hdrBytes = hdr.toArrayBuffer();
  const odata = new Uint8Array(hdrBytes.byteLength + img8.byteLength);
  odata.set(new Uint8Array(hdrBytes), 0);
  odata.set(img8, hdrBytes.byteLength);
  return odata;
}
function iwi2nii(arrayBuffer) {
  const iwi = decode(new Uint8Array(arrayBuffer));
  return iwi2niiCore(iwi);
}
function nii2iwi(hdr, img, isEncodeCBOR = false) {
  const iwi = {
    imageType: {
      dimension: hdr.dims[0],
      componentType: "uint8",
      pixelType: "Scalar",
      components: 1
    },
    direction: new Float64Array(9),
    origin: [],
    size: [],
    spacing: [],
    metadata: []
  };
  for (let i = 0; i < hdr.dims[0]; i++) {
    iwi.spacing[i] = hdr.pixDims[i + 1];
    iwi.size[i] = hdr.dims[i + 1];
  }
  if (hdr.dims[0] > 2) {
    iwi.origin[0] = -hdr.affine[0][3];
    iwi.origin[1] = -hdr.affine[1][3];
    iwi.origin[2] = hdr.affine[2][3];
    const mm = [hdr.pixDims[1], hdr.pixDims[2], hdr.pixDims[3]];
    iwi.direction[0] = hdr.affine[0][0] / -mm[0];
    iwi.direction[1] = hdr.affine[1][0] / -mm[0];
    iwi.direction[2] = hdr.affine[2][0] / mm[0];
    iwi.direction[3] = hdr.affine[0][1] / -mm[1];
    iwi.direction[4] = hdr.affine[1][1] / -mm[1];
    iwi.direction[5] = hdr.affine[2][1] / mm[1];
    iwi.direction[6] = hdr.affine[0][2] / -mm[2];
    iwi.direction[7] = hdr.affine[1][2] / -mm[2];
    iwi.direction[8] = hdr.affine[2][2] / mm[2];
  }
  if (hdr.datatypeCode === 128) {
    iwi.imageType.pixelType = "RGB";
    iwi.imageType.componentType = "uint8";
    iwi.imageType.components = 3;
    iwi.data = new Uint8Array(img);
  } else if (hdr.datatypeCode === 64) {
    iwi.imageType.componentType = "float64";
    iwi.data = new Float64Array(img);
  } else if (hdr.datatypeCode === 16) {
    iwi.imageType.componentType = "float32";
    iwi.data = new Float32Array(img);
  } else if (hdr.datatypeCode === 2) {
    iwi.imageType.componentType = "uint8";
    iwi.data = new Uint8Array(img);
  } else if (hdr.datatypeCode === 4) {
    iwi.imageType.componentType = "int16";
    iwi.data = new Int16Array(img);
  } else if (hdr.datatypeCode === 8) {
    iwi.imageType.componentType = "int32";
    iwi.data = new Int32Array(img);
  } else {
    throw new Error(`NIfTI voxels use unsupported datatype ${hdr.datatypeCode}.`);
  }
  iwi.size = iwi.size.map((num) => BigInt(num));
  if (isEncodeCBOR) {
    return encode(iwi);
  }
  return iwi;
}
export {
  iwi2nii,
  iwi2niiCore,
  iwm2mesh,
  iwm2meshCore,
  mesh2iwm,
  nii2iwi
};
//# sourceMappingURL=@niivue_cbor-loader.js.map
