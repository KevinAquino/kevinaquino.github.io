// Generated file. To retain edits, remove this comment.
import { InterfaceTypes, runPipelineNode } from 'itk-wasm';
import path from 'path';
import { fileURLToPath } from 'url';
/**
 * Read an image file format and convert it to the itk-wasm file format
 *
 * @param {string} serializedImage - Input image serialized in the file format
 * @param {Hdf5ReadImageNodeOptions} options - options object
 *
 * @returns {Promise<Hdf5ReadImageNodeResult>} - result object
 */
async function hdf5ReadImageNode(serializedImage, options = {}) {
    const mountDirs = new Set();
    const desiredOutputs = [
        { type: InterfaceTypes.JsonCompatible },
        { type: InterfaceTypes.Image },
    ];
    mountDirs.add(path.dirname(serializedImage));
    const inputs = [];
    const args = [];
    // Inputs
    const serializedImageName = serializedImage;
    args.push(serializedImageName);
    mountDirs.add(path.dirname(serializedImageName));
    // Outputs
    const couldReadName = '0';
    args.push(couldReadName);
    const imageName = '1';
    args.push(imageName);
    // Options
    args.push('--memory-io');
    if (options.informationOnly) {
        options.informationOnly && args.push('--information-only');
    }
    const pipelinePath = path.join(path.dirname(fileURLToPath(import.meta.url)), 'pipelines', 'hdf5-read-image');
    const { returnValue, stderr, outputs } = await runPipelineNode(pipelinePath, args, desiredOutputs, inputs, mountDirs);
    if (returnValue !== 0 && stderr !== "") {
        throw new Error(stderr);
    }
    const result = {
        couldRead: outputs[0]?.data,
        image: outputs[1]?.data,
    };
    return result;
}
export default hdf5ReadImageNode;
//# sourceMappingURL=hdf5-read-image-node.js.map