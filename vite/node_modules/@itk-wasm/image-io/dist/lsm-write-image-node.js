// Generated file. To retain edits, remove this comment.
import { InterfaceTypes, runPipelineNode } from 'itk-wasm';
import path from 'path';
import { fileURLToPath } from 'url';
/**
 * Write an itk-wasm file format converted to an image file format
 *
 * @param {Image} image - Input image
 * @param {string} serializedImage - Output image serialized in the file format.
 * @param {LsmWriteImageNodeOptions} options - options object
 *
 * @returns {Promise<LsmWriteImageNodeResult>} - result object
 */
async function lsmWriteImageNode(image, serializedImage, options = {}) {
    const mountDirs = new Set();
    const desiredOutputs = [
        { type: InterfaceTypes.JsonCompatible },
    ];
    const inputs = [
        { type: InterfaceTypes.Image, data: image },
    ];
    const args = [];
    // Inputs
    const imageName = '0';
    args.push(imageName);
    // Outputs
    const couldWriteName = '0';
    args.push(couldWriteName);
    const serializedImageName = serializedImage;
    args.push(serializedImageName);
    mountDirs.add(path.dirname(serializedImageName));
    // Options
    args.push('--memory-io');
    if (options.informationOnly) {
        options.informationOnly && args.push('--information-only');
    }
    if (options.useCompression) {
        options.useCompression && args.push('--use-compression');
    }
    const pipelinePath = path.join(path.dirname(fileURLToPath(import.meta.url)), 'pipelines', 'lsm-write-image');
    const { returnValue, stderr, outputs } = await runPipelineNode(pipelinePath, args, desiredOutputs, inputs, mountDirs);
    if (returnValue !== 0 && stderr !== "") {
        throw new Error(stderr);
    }
    const result = {
        couldWrite: outputs[0]?.data,
    };
    return result;
}
export default lsmWriteImageNode;
//# sourceMappingURL=lsm-write-image-node.js.map